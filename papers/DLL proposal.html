<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
		<title>A Proposal to add Classes and Functions Required for Dynamic Library Load</title>
		<meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
		<meta http-equiv="Content-Language" content="en-us">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

		<style type="text/css">
			.addition { color: green; }
			.right { float:right; }
		</style>

	</head>
	<body bgcolor="#ffffff">
		<address>Document number: P???R0</address>
		<address>Project: Programming Language C++</address>
		<address>Audience: Library Evolution Working Group</address>
		<address>&nbsp;</address>
		<address>Antony Polukhin &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;</address>
		<address>&nbsp;</address>
		<address>Date: 2016-01-31</address>
		<h1>A Proposal to add Classes and Functions Required for Dynamic Library Load</h1>

		<h2>I. Introduction and Motivation</h2>
		<p>Adding a specific features to an existing software applications at runtime could be useful in many cases. Such extensions, or plugins,
            are usually implemented using Dynamic Library Modules (DLL, SO/DSO) loaded at runtime.</p>
		<p>Current C++ Standard lacks support for dynamic library loading(DLL). This proposal attempts to fix that and provide a simple to use classes and functions for DLL.</p>
		<p>A proof of concept implementation available at: <a href="http://boost.org/libs/dll">Boost.DLL</a>.
		</p>


		<h2>II. Impact on the Standard</h2>
		<p>This proposal is a pure library extension. It does not propose changes to
			existing headers. It does not require any changes in the core 
			language and it could be implemented in standard C++.
		</p>

		<h2>III. Design Decisions</h2>
		<h3>A. Usage of <code>std::experimental::filesystem::path</code></h3>
		<p>To simplify library usage <code>std::experimental::filesystem::path</code> is used for specifying paths . All the <code>path</code> related overhead is minor,
            comparing to the time of loading shared object or getting information about shared object location.</p>
		<h3>B. Stick to the Filesystem error reporting scheme.</h3>
		<p>Provide two overloads for some functions, one that throws an exception to report system errors, and another that sets an <code>error_code</code>. This supports two common use cases:</p>
            <ul>
                <li>Uses where file system errors are truly exceptional and indicate a serious failure.</li>
                <li>Uses where file system errors are routine and do not necessarily represent failure.</li>
            </ul>
		<h3>C. Do not take care of mangling.</h3>
			<p>C++ symbol mangling depend on compiler and platform. Existing attempts to load mangled symbol by unmangled name
            result in significant complexity and memory usage growth and overall slowdown of loading symbol from library.</p>
            <p>While no good solution was found for loading mangled symbol by unmangled name, this proposal concentrates on loading symbols by exact name match.</p>
		<h3>D. Provide functions for simple usage.</h3>
			<p>Keeping a library loaded while using the imported symbol could be hard and error prone for some users. For the simplicity of those users, <code>import</code>
            functions were provided. Those functions return a symbol wrapped in a helper class along with loaded library. In that way while returned value in in scope, the
            library won't be unloaded, so the user does not need to take care of loaded library lifetime.</p>
		<h3>E. Do not search libraries in system specific paths by default.</h3>
			<p>Searching paths for a specified library may affect load times and make the proposed library less efficient. It is assumed to be the most common case, that
            user exactly knows were the desired for load library is located and provides either absolute path or relative to current directory path. For that case searching
            system specific paths affects performance and increases the chance of finding wrong library with the same name. Because some operating systems search
            system paths even if relative path is provided, the requirement to not do that is implicitly described in proposed wording.</p>

		<h2>IV. Proposed wording relative to N4567</h2>

<h3>31 Dynamic library load <span class="right">[dll]</span></h3>
<h4>31.1 General <span class="right">[dll.general]</span></h4>
<p>
    Headers &lt;experimental/dll&gt; and &lt;experimental/import&gt; define classes and functions suitable for dynamic library load. For those headers term 'symbol' relates to a
    function or variable that can be loaded from library at runtime. Term 'symbol name' relates to a character identifier of a symbol, using which
    symbol can be loaded from library. For symbols declared with extern "C" in library source codes 'symbol name' is the name of the
    variable of function. 'symbol name' in C++ library source codes without extern "C" is the mangled name of the variable of function.
</p>

<h4>31.2 Error reporting <span class="right">[dll.errors]</span></h4>
<p>
    Functions not having an argument of type error_code& report errors as follows, unless otherwise specified:
    <ul>
    <li>When a call by the implementation to an operating system or other underlying API results in an error that
    prevents the function from meeting its specifications, an exception of type system_error is thrown.</li>

    <li>Failure to allocate storage is reported by throwing an exception as described in the C++ standard,
    17.6.4.10 [res.on.exception.handling].</li>

    <li>Destructors throw nothing.</li>
    </ul>

    Functions having an argument of type error_code& report errors as follows, unless otherwise specified:
    <ul>
    <li>If a call by the implementation to an operating system or other underlying API results in an 
    error that prevents the function from meeting its specifications, the error_code& argument is set as
    appropriate for the specific error. Otherwise, clear() is called on the error_code& argument.</li>

    <li>Failure to allocate storage is reported by throwing an exception as described in the C++ standard, 17.6.4.10 [res.on.exception.handling].</li>
    </ul>
</p>

<h4>31.3 Header &lt;experimental/dll&gt; <span class="right">[dll.dll]</span></h4>
<pre>
namespace std {
  namespace experimental {

    // shared object open modes
    enum class dll_mode {
        default_mode = 0,
        dont_resolve_dll_references,    // DONT_RESOLVE_DLL_REFERENCES
        load_ignore_code_authz_level,   // LOAD_IGNORE_CODE_AUTHZ_LEVEL
        rtld_lazy,                      // RTLD_LAZY
        rtld_now,                       // RTLD_NOW
        rtld_global,                    // RTLD_GLOBAL
        rtld_local,                     // RTLD_LOCAL
        rtld_deepbind,                  // RTLD_DEEPBIND
        append_decorations,             // Any value that can not be received by applying binary OR to any set of the previous modes
        search_system_folders           // Any value that can not be received by applying binary OR to any set of the previous modes
    };

    constexpr dll_mode operator|(dll_mode left, dll_mode right) noexcept;
    constexpr dll_mode&amp; operator|=(dll_mode&amp; left, dll_mode right) noexcept;
    constexpr dll_mode operator&(dll_mode left, dll_mode right) noexcept;
    constexpr dll_mode&amp; operator&=(dll_mode&amp; left, dll_mode right) noexcept;
    constexpr dll_mode operator^(dll_mode left, dll_mode right) noexcept;
    constexpr dll_mode&amp; operator^=(dll_mode&amp; left, dll_mode right) noexcept;
    constexpr dll_mode&amp; operator~(dll_mode&amp; lhs) noexcept;

    // shared object holder class
    class shared_library;

    bool operator==(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator!=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&lt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&gt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&lt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&gt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;

    // free functions
    template&lt;class T&gt;
    filesystem::path symbol_location(const T&amp; symbol, error_code&amp; ec);
    template&lt;class T&gt;
    boost::filesystem::path symbol_location(const T&amp; symbol);

    filesystem::path this_line_location(error_code&amp; ec);
    filesystem::path this_line_location();

    filesystem::path program_location(error_code&amp; ec);
    filesystem::path program_location();
  }

  // support
  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;experimental::shared_library&gt;;
  template &lt;&gt; struct hash&lt;experimental::dll_mode&gt;;
}

</pre>
<p>
The value of each enum dll_mode constant shall be the same as the value of the macro shown in the above synopsis if that macro is available on the platform or 0 otherwise.
</p>

<h4>31.3.1 Enum dll_mode <span class="right">[dll.dll_mode]</span></h4>
<p>
    Enum dll_mode provides library load modes. Each of system family provides own modes, flags not supported by a particular platform must be set to 0. Special modes are listened below:
</p>

<pre>
append_decorations
    <i>Effects:</i> Appends a platform specific extensions and prefixes to shared library filename before trying to load it. If load attempts fails, tries to load with exactly specified name.
    <i>Platforms:</i> Windows, POSIX
    <i>Example:</i>
        // Tries to open
        //      `./my_plugins/plugin1.dll` and `./my_plugins/libplugin1.dll` on Windows
        //      `./my_plugins/libplugin1.so` on Linux
        //      `./my_plugins/libplugin1.dylib` and `./my_plugins/libplugin1.so` on MacOS.
        // If that fails, loads `./my_plugins/plugin1`
        shared_library lib("./my_plugins/plugin1", dll_mode::append_decorations);

default_mode
    Default open mode for a particular platform.

search_system_folders
    <i>Effects:</i> Allows loading an object from system specific library folders.
</pre>

<h4>31.3.1.1 dll_mode operators <span class="right">[dll.dll_mode.operators]</span></h4>
<pre>
    constexpr dll_mode operator|(dll_mode lhs, dll_mode rhs) noexcept;
    constexpr dll_mode&amp; operator|=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode operator&(dll_mode lhs, dll_mode rhs) noexcept;
    constexpr dll_mode&amp; operator&=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode operator^(dll_mode lhs, dll_mode rhs) noexcept;
    constexpr dll_mode&amp; operator^=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode&amp; operator~(dll_mode&amp; lhs) noexcept;

    <i>Effects:</i> Converts parameters to unsigned integral type capable of storing them, applies a corresponding
    binary operator and returns the result as dll_mode.
</pre>

<h4>31.3.1.2 dll_mode hash support<span class="right">[dll.dll_mode.hash]</span></h4>
<pre>
template &lt;&gt; struct hash&lt;experimental::dll_mode&gt;;
    The template specialization shall meet the requirements of class template hash (20.9.13).
</pre>


<h4>31.3.2 Class shared_library <span class="right">[dll.shared_library]</span></h4>
<p>
    The class shared_library provides means to load library objects, check that library exports symbol with specified symbol name and load the symbol.
</p>
<p>
    shared_library instances share reference count to an actual loaded library, so it is safe and memory efficient to have multiple instances of
    shared_library referencing the same library even if those instances were loaded using different paths (relative + absolute) referencing the same
    library object.
</p>
<p>
    It must be safe to concurrently load, unload and get symbols from any libraries using different shared_library instances. If current platform does
    not guarantee safe concurrent load, loads using shared_library must be serialized by implementation.
</p>
<p>
    shared_library uses the same error reporting scheme as error reporting in filesystem [fs.err.report], except that system_error exception is thrown instead of filesystem_error.
</p>
<pre>
namespace std {
  namespace experimental {

    class shared_library {
    public:
      typedef platform_specific native_handle_t;

      // construct/copy/destruct
      shared_library() noexcept;
      shared_library(const shared_library&amp; lib);
      shared_library(const shared_library&amp; lib, error_code&amp; ec);
      shared_library(shared_library&amp;&amp; lib) noexcept;
      explicit shared_library(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
      shared_library(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
      shared_library(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);
      shared_library&amp; operator=(const shared_library&amp; lib);
      shared_library&amp; operator=(shared_library&amp;&amp; lib) noexcept;
      ~shared_library();

      // public member functions
      shared_library&amp; assign(const shared_library&amp; lib, error_code&amp; ec);
      shared_library&amp; assign(const shared_library&amp; lib);

      void load(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
      void load(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
      void load(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);

      void unload() noexcept;
      bool is_loaded() const noexcept;
      explicit operator bool() const noexcept;

      bool has(const char* symbol_name) const noexcept;
      bool has(const string&amp; symbol_name) const noexcept;

      template &lt;typename SymbolT&gt;
      decltype(auto) get(const char* symbol_name) const;

      template &lt;typename SymbolT&gt;
      decltype(auto) get(const string&amp; symbol_name) const;

      native_handle_t native() const noexcept;

      filesystem::path location() const;
      filesystem::path location(error_code&amp; ec) const;
    };

  }
}
</pre>

<h4>31.3.3.1 shared_library constructors <span class="right">[dll.shared_library.constr]</span></h4>
<pre>
shared_library() noexcept;
    <i>Effects:</i> Creates shared_library that does not reference any object.
    <i>Postconditions:</i> is_loaded() returns false. 

shared_library(const shared_library&amp; lib);
shared_library(const shared_library&amp; lib, error_code&amp; ec);
    <i>Effects:</i> *this loads the same library that was loaded in lib or if lib is not loaded sets this* 
    to default constructed state.
    <i>Postconditions:</i> lib == *this
    <i>Throws:</i> As specified in [dll.errors]

shared_library(shared_library&amp;&amp; lib) noexcept;
    <i>Effects:</i> Assigns the state of lib to *this and sets lib to a default constructed state.
    <i>Remarks:</i> Does not invalidate existing symbols and functions loaded from lib.
    <i>Postconditions:</i> lib.is_loaded() returns false, this->is_loaded() return true.

explicit shared_library(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
shared_library(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode= dll_mode::default_mode);
shared_library(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);
    <i>Effects:</i> Same as calling shared_library::load() with same parameters.
    <i>Throws:</i> As specified in [dll.errors].
</pre>


<h4>31.3.3.2 shared_library destructor <span class="right">[dll.shared_library.destr]</span></h4>
<pre>
~shared_library();
    <i>Effects:</i> Destroys the shared_library by calling unload(). If the actual library was loaded multiple times by different instances of shared_library,
    the actual library won't be unloaded until there is at least one instance of shared_library referencing it.
</pre>


<h4>31.3.3.3 shared_library assignment <span class="right">[dll.shared_library.assign]</span></h4>
<pre>
shared_library&amp; operator=(const shared_library&amp; lib);
    <i>Effects:</i> Same as calling this->assign(lib)

shared_library&amp; operator=(shared_library&amp;&amp; lib) noexcept;
    <i>Effects:</i> If this->is_loaded() then calls this->unload(), then assigns the state of lib to *this and sets lib to a default constructed state.
    <i>Remarks:</i> Does not invalidate existing symbols and functions loaded from lib.
    <i>Postconditions:</i> lib.is_loaded() returns false, this->is_loaded() return true.
</pre>


<h4>31.3.3.4 shared_library members<span class="right">[dll.shared_library.member]</span></h4>
<pre>
shared_library&amp; assign(const shared_library&amp; lib, error_code&amp; ec);
shared_library&amp; assign(const shared_library&amp; lib);
    <i>Effects:</i> If *this is loaded, then unloads it. Makes *this share the same shared object as lib. 
    <i>Postconditions:</i> lib.location() == this->location(), lib == *this
    <i>Throws:</i> As specified in [dll.errors]

void load(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
void load(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
void load(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);
    Loads a library by specified path with a specified mode. If some library is already loaded in this instance,
    load will call unload() first.

    Must be capable of loading current executable if absolute or relative path to the executable was provided as library_path. Must try to load
    library with changed name and applied extension only if (mode & dll_mode::append_decorations) is not 0. Must
    attempt to load a library from system specific shared library directories only if library_path contains only file name and
    (mode & dll_mode::search_system_folders) is not 0. During loads from system
    specific folders file name modification rules from above apply. If with dll_mode::search_system_folders more than one
    loaded module has the same base name and extension, the function loads any first matching module.
    If (mode & dll_mode::search_system_folders) is 0, then any relative path or path that contains only filename must be treated as a
    path in current working directory.

    Library open mode is equal to (mode & ~dll_mode::search_system_folders & ~dll_mode::append_decorations) converted to a platform specific
    type representing library load modes and adjusted to satisfy the dll_mode::search_system_folders requirements from above. If mode is
    invalid for current platform, attempts to adjust the mode by applying dll_mode::rtld_lazy
    and throws if resulting mode is invalid. <i>Example:</i> If mode on POSIX was set to rtld_local, then it will be adjusted
    to rtld_lazy | rtld_local.

    <i>Throws:</i> As specified in [dll.errors]

void unload() noexcept;
    <i>Effects:</i> Unloads a shared library.
    <i>Remarks:</i> If library was loaded multiple times by different instances of shared_library, the actual library object won't
    be unloaded until there is at least one instance of shared_library holding a reference to it.
    <i>Postconditions:</i> this->is_loaded() returns false.

bool is_loaded() const noexcept;
    <i>Returns:</i> true if *this references a library object.

explicit operator bool() const noexcept;
    <i>Returns:</i> true if *this references a library object.

bool has(const char* symbol_name) const noexcept;
bool has(const string&amp; symbol_name) const noexcept;
    <i>Returns:</i> true if *this references a library object and symbol with symbol_name could be loaded from it.

template &lt;typename SymbolT&gt;
decltype(auto) get(const char* symbol_name) const;
template &lt;typename SymbolT&gt;
decltype(auto) get(const string&amp; symbol_name) const;
    <i>Returns:</i> Imported from library symbol, throws if symbol does not exist or if the library was not loaded.
    <i>Return type:</i> SymbolT&amp; if SymbolT is a type, function signature of function pointer; SymbolT if SymbolT is a member function pointer.
    <i>Remarks:</i> It's the user responsibility to provide valid SymbolT for imported symbol. However implementations may provide additional checks for
    matching SymbolT type and actually imported symbol. [Note: For example implementations
    may check that SymbolT is a function pointer and that imported symbol allows execution (imported from a section with execute permissions). ]

    <i>Throws:</i> As specified in [dll.errors]

native_handle_t native() const noexcept;
    <i>Returns:</i> Native handler of the loaded library or default constructed native_handle_t if library is not loaded.

filesystem::path location() const;
filesystem::path location(error_code&amp; ec) const;
    <i>Returns:</i> Full path and name to library object currently loaded, throws if library was not loaded.
    <i>Throws:</i> As specified in [dll.errors]
</pre>

<h4>31.3.3.5 shared_library free operators<span class="right">[dll.shared_library.operators]</span></h4>
<pre>
<p>
    shared_library provides fast comparison operators that compare the referenced library objects.
</p>
bool operator==(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() == rhs.native()

bool operator!=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() != rhs.native()

bool operator&lt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() &lt; rhs.native()

bool operator&gt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() &gt; rhs.native()

bool operator&lt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() &lt;= rhs.native()

bool operator&gt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    <i>Returns:</i> lhs.native() &gt;= rhs.native()

</pre>

<h4>31.3.3.6 shared_library hash support<span class="right">[dll.shared_library.hash]</span></h4>
<pre>
template &lt;&gt; struct hash&lt;experimental::shared_library&gt;;
    The template specialization shall meet the requirements of class template hash (20.9.13).
</pre>

<h4>31.3.4 Runtime path functions<span class="right">[dll.location]</span></h4>
<pre>
template&lt;class T&gt;
filesystem::path symbol_location(const T&amp; symbol, error_code&amp; ec);
template&lt;class T&gt;
boost::filesystem::path symbol_location(const T&amp; symbol);
    <i>Returns:</i> Full path and name of library or executable that contains symbol
    <i>Throws:</i> As specified in [dll.errors]

filesystem::path this_line_location(error_code&amp; ec);
filesystem::path this_line_location();
    <i>Returns:</i> Full path and name of library or executable that contains line of source code in which this_line_location was called
    <i>Throws:</i> As specified in [dll.errors]

filesystem::path program_location(error_code&amp; ec);
filesystem::path program_location();
    <i>Returns:</i> Full path and name of the executable.
    <i>Throws:</i> As specified in [dll.errors]
</pre>

<h4>31.4 Header &lt;experimental/import&gt; <span class="right">[dll.import.header]</span></h4>
<pre>
#include &lt;experimental/dll&gt;
#include &lt;type_traits&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

namespace std {
  namespace experimental {

    template &lt;typename SymbolT&gt;
    using imported_t = conditional_t&lt;is_object_v&lt;SymbolT&gt;, shared_ptr&lt;SymbolT&gt;, function&lt;SymbolT&gt;&gt;;

    // functions for importing a symbol
    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const char* symbol_name, dll_mode mode = dll_mode::default_mode);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const string&amp; symbol_name, dll_mode mode = dll_mode::default_mode);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const char* symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const string&amp; symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const char* symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const string&amp; symbol_name);
  }
}

import functions are meant to simplify dynamic library loads of symbols by keeping library loaded while imported symbol is in scope:
[Example:
    auto foo_function = import&lt;void(string&amp;&amp;)&gt;("/plugin_directory/libplugin.so", "foo_function");
    foo_function("Test");
]

</pre>

<h4>31.4.1 import functions <span class="right">[dll.import.func]</span></h4>
<pre>
template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const char* symbol_name, dll_mode mode = dll_mode::default_mode);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const string&amp; symbol_name, dll_mode mode = dll_mode::default_mode);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const char* symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const string&amp; symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const char* symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const string&amp; symbol_name);
    <i>Effects:</i> Loads a symbol with name symbol_name from library and returns it wrapped in class that implements semantics
    of shared ownership of library; the last remaining owner is responsible for releasing the resources associated with the
    library. mode must be passed to shared_library constructor or shared_library::load function.
    <i>Remarks:</i> It's the user responsibility to provide valid SymbolT for imported symbol.
    <i>Return type:</i> imported_t&lt;SymbolT&gt; that keeps instance an of shared_library internally
    <i>Returns:</i> variable that keeps shared_library and imported symbol and provides access to the symbol only.
    <i>Throws:</i> As specified in [dll.errors]

</pre>

		<h2>V. Feature-testing macro</h2>
		<p>For the purposes of SG10 it is sufficient to check for header &lt;experimental/dll&gt; or &lt;experimental/import&gt; using __has_include.</p>


		<h2>V. Revision History</h2>
		<p>Revision 0:</p>
		<ul>
			<li>
				Initial proposal
			</li>
		</ul>


		<h2>VI. References</h2>
		<p>[<a name="Boost.DLL">Boost.DLL</a>] Boost DLL library.
			Available online at <a href="http://boost.org/libs/dll">http://boost.org/libs/dll</a></p>
		<p>&nbsp;</p>

		<h2>VII. Acknowledgements</h2>
		<p>Walter E. Brown provided numerous comments, corrections, and suggestions for this proposal.
        Klemens Morgenstern highlighted some of the missing functionality in Boost.DLL and provided implementation of mangled symbols load,
        that showed complexities of such approach.</p>





</body></html>

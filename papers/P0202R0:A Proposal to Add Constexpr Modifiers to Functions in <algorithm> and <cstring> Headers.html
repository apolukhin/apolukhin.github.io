<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
		<title>A Proposal to Add Constexpr Modifiers to Functions in &lt;algorithm&gt; and &lt;cstring&gt; Headers</title>
		<meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
		<meta http-equiv="Content-Language" content="en-us">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

		<style type="text/css">
			.addition { color: green; text-decoration: underline; }
		</style>

	</head>
	<body bgcolor="#ffffff">
		<address>Document number: P????R0</address>
		<address>Project: Programming Language C++, Library Evolution Working Group</address>
		<address>&nbsp;</address>
		<address>Antony Polukhin &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;</address>
		<address>&nbsp;</address>
		<address>Date: 2016-01-11</address>
		<h1>Add Constexpr Modifiers to Functions in &lt;algorithm&gt; and &lt;cstring&gt; Headers</h1>

		<h2>I. Introduction and Motivation</h2>
		<p>The Standard Library provides a great collection of containers and algorithms, many of which currently lack constexpr support.
			Even a simple <code>constexpr</code> usage requires reimplementing a big bunch of the Standard Library. Consider the simple example:</p>
		<p></p><blockquote><pre>#include &lt;array&gt;
#include &lt;algorithm&gt;
 
int main() {
	// OK
	constexpr std::array&lt;char, 6&gt; a { 'H', 'e', 'l', 'l', 'o' };

	// Failures:
	// * std::find is not constexpr
	// * std::array::rbegin(), std::array::rend() are not constexpr
	// * std::array::reverse_iterator is not constexpr
	constexpr auto it = std::find(a.rbegin(), a.rend(), 'H');
}
</pre></blockquote><p></p>
		<p>This proposal concentrates on <code>constexpr</code> algorithms, deferring simple containers and iterators to a separate proposal.</p>
		<p>A proof of concept implementation for some algorithms, is available at:
				<a href="https://bitbucket.org/rhalbersma/xstd/src/42553df6107623c71163f104b6f3cc550c245b4b/include/xstd/algorithm.hpp?at=default&amp;fileviewer=file-view-default">rhalbersma</a>.
		</p>


		<h2>II. Impact on the Standard</h2>
		<p>This proposal is a pure library extension. It proposes changes to
			existing headers <code>&lt;cstring&gt;</code> and <code>&lt;algorithm&gt;</code> such that the changes do not break existing code
			and do not degrade performance. It does not require any changes in the core 
			language in simple cases of non assembly optimized Standard Library, and it could be implemented in standard C++, except for
			the <code>memcpy</code> and <code>memmove</code> functions.
		</p>
		<p>Depending on the Standard Library implementation this proposal may rely on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">P0031R0</a>.
			P0031R0 provides constexpr additions to <code>std::advance</code>, <code>std::distance</code>, <code>std::move_iterator</code>
			and other functions and classes. Those may be used by some implementations of <code>&lt;algorithm&gt;</code> header.
		</p>

		<h2>III. Design Decisions</h2>
		<h3>A. <code>&lt;cstring&gt;</code> must have <code>constexpr</code> additions</h3>
		<p>Existing implementations of the functions in <code>&lt;algorithm&gt;</code> header usually rely on functions from <code>&lt;cstring&gt;</code>.
			For example <code>std::copy</code> usually takes advantage of <code>std::memmove</code> for POD types. This leads us to situation, that
			functions in <code>&lt;algorithm&gt;</code> header could not be marked as <code>constexpr</code> without <code>constexpr</code> marking functions from <code>&lt;cstring&gt;</code>.</p>
		<h3>B. <code>std::memmove</code> and <code>std::memcpy</code> must have <code>constexpr</code> additions</h3>
		<p><code>std::memmove</code> and <code>std::memcpy</code> accept <code>void*</code> and <code>const void*</code> parameters. This makes
			them impossible to implement in pure C++ as <code>constexpr</code>, because constant expressions can not evaluate a conversion from
			type <code>cv void *</code> to a pointer-to-object type according to [expr.const].</p>
			<p>However those functions are not only popular, but also are widely used across Standard Library to gain better performance. Not making them <code>constexpr</code>
			will force standard Library developer to have compiler intrinsics for them anyway. This is a hard step that must be done.</p>
		<h3>C. Assumption that it is possible to implement all the proposed changes without affecting language core, especially [expr.const]</h3>
			There are many Standard Library implementations nowadays, including some proprietary. It is impossible to investigate all of them to be 100% sure that
			no performance degradation possible.<p></p>
			<p>This proposal assumes that:
			</p><ul>
				<li>If algorithm uses compiler intrinsics, then those intrinsics could be made <code>constexpr</code> by compiler vendors.</li>
				<li>If algorithm uses assembly optimization, then that assembly could be turned into <code>constexpr</code> compiler intrinsic.</li>
				<li>If algorithm uses external functions, then those functions could be made inline and marked <code>constexpr</code> or could be replaced with intrinsics.</li>
				<li>Modern compilers are good in code optimization, so a decently small amount of algorithms use assembly or intrinsics.</li>
			</ul><p></p>

		<h2>IV. Proposed modifications for N4567</h2>
		<p>All the additions to the Standard are marked with <span class="addition">underlined green</span>.</p>
		<h3>A. Modifications to "21.8 Null-terminated sequence utilities" [c.strings]</h3>
		<pre>The headers shall not define the types char16_t, char32_t, and wchar_t (2.11).

<span class="addition">All the functions from &lt;cstring&gt; header must be marked with constexpr, except the strcoll, strxfrm, strerror functions.</span>

The function signature strchr(const char*, int) shall be replaced by the two declarations:
    <span class="addition">constexpr</span> const char* strchr(const char* s, int c);
    <span class="addition">constexpr</span> char* strchr(char* s, int c);
both of which shall have the same behavior as the original declaration.

The function signature strpbrk(const char*, const char*) shall be replaced by the two declarations:
    <span class="addition">constexpr</span> const char* strpbrk(const char* s1, const char* s2);
    <span class="addition">constexpr</span> char* strpbrk(char* s1, const char* s2);
both of which shall have the same behavior as the original declaration.

The function signature strrchr(const char*, int) shall be replaced by the two declarations:
    <span class="addition">constexpr</span> const char* strrchr(const char* s, int c);
    <span class="addition">constexpr</span> char* strrchr(char* s, int c);
both of which shall have the same behavior as the original declaration.

The function signature strstr(const char*, const char*) shall be replaced by the two declarations:
    <span class="addition">constexpr</span> const char* strstr(const char* s1, const char* s2);
    <span class="addition">constexpr</span> char* strstr(char* s1, const char* s2);
both of which shall have the same behavior as the original declaration.

The function signature memchr(const void*, int, size_t) shall be replaced by the two declarations:
    <span class="addition">constexpr</span> const void* memchr(const void* s, int c, size_t n);
    <span class="addition">constexpr</span> void* memchr(void* s, int c, size_t n);
both of which shall have the same behavior as the original declaration.
		</pre>


		<h3>B. Modifications to "Header &lt;algorithm&gt; synopsis" [algorithms.general]</h3>
		<pre>
#include &lt;initializer_list&gt;

namespace std {

// 25.2, non-modifying sequence operations:
template &lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> bool all_of(InputIterator first, InputIterator last, Predicate pred);

template &lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> bool any_of(InputIterator first, InputIterator last, Predicate pred);

template &lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> bool none_of(InputIterator first, InputIterator last, Predicate pred);

template&lt;class InputIterator, class Function&gt;
<span class="addition">constexpr</span> Function for_each(InputIterator first, InputIterator last, Function f);

template&lt;class InputIterator, class T&gt;
<span class="addition">constexpr</span> InputIterator find(InputIterator first, InputIterator last, const T&amp; value);

template&lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> InputIterator find_if(InputIterator first, InputIterator last, Predicate pred);

template&lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> InputIterator find_if_not(InputIterator first, InputIterator last, Predicate pred);

template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> ForwardIterator1 find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> ForwardIterator1 find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template&lt;class InputIterator, class ForwardIterator&gt;
<span class="addition">constexpr</span> InputIterator find_first_of(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2);

template&lt;class InputIterator, class ForwardIterator, class BinaryPredicate&gt;
<span class="addition">constexpr</span> InputIterator find_first_of(InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred);

template&lt;class ForwardIterator&gt;
<span class="addition">constexpr</span> ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last);

template&lt;class ForwardIterator, class BinaryPredicate&gt;
<span class="addition">constexpr</span> ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template&lt;class InputIterator, class T&gt;
<span class="addition">constexpr</span> typename iterator_traits&lt;InputIterator&gt;::difference_type count(InputIterator first, InputIterator last, const T&amp; value);

template&lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> typename iterator_traits&lt;InputIterator&gt;::difference_type count_if(InputIterator first, InputIterator last, Predicate pred);

template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred);

template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> pair&lt;InputIterator1, InputIterator2&gt;
    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred);

template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred);

template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred);

template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);

template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, BinaryPredicate pred);

template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> ForwardIterator1 search( ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);

template&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;
<span class="addition">constexpr</span> ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);

template&lt;class ForwardIterator, class Size, class T&gt;
<span class="addition">constexpr</span> ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Size count, const T&amp; value);

template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt;
<span class="addition">constexpr</span> ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Size count, const T&amp; value, BinaryPredicate pred);

// 25.3, modifying sequence operations:
// 25.3.1, copy:
template&lt;class InputIterator, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);

template&lt;class InputIterator, class Size, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator copy_n(InputIterator first, Size n, OutputIterator result);

template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
<span class="addition">constexpr</span> OutputIterator copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);

template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
<span class="addition">constexpr</span> BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);

// 25.3.2, move:
template&lt;class InputIterator, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator move(InputIterator first, InputIterator last, OutputIterator result);

template&lt;class BidirectionalIterator1, class BidirectionalIterator2&gt;
<span class="addition">constexpr</span> BidirectionalIterator2 move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);

// 25.3.3, swap:
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);

template&lt;class ForwardIterator1, class ForwardIterator2&gt;
<span class="addition">constexpr</span> void iter_swap(ForwardIterator1 a, ForwardIterator2 b);

template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
<span class="addition">constexpr</span> OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt;
<span class="addition">constexpr</span> OutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);

template&lt;class ForwardIterator, class Predicate, class T&gt;
<span class="addition">constexpr</span> void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T&amp; new_value);

template&lt;class InputIterator, class OutputIterator, class T&gt;
<span class="addition">constexpr</span> OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; old_value, const T&amp; new_value);

template&lt;class InputIterator, class OutputIterator, class Predicate, class T&gt;
<span class="addition">constexpr</span> OutputIterator replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T&amp; new_value);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class OutputIterator, class Size, class T&gt;
<span class="addition">constexpr</span> OutputIterator fill_n(OutputIterator first, Size n, const T&amp; value);

template&lt;class ForwardIterator, class Generator&gt;
<span class="addition">constexpr</span> void generate(ForwardIterator first, ForwardIterator last, Generator gen);

template&lt;class OutputIterator, class Size, class Generator&gt;
<span class="addition">constexpr</span> OutputIterator generate_n(OutputIterator first, Size n, Generator gen);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class ForwardIterator, class Predicate&gt;
<span class="addition">constexpr</span> ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);

template&lt;class InputIterator, class OutputIterator, class T&gt;
<span class="addition">constexpr</span> OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value);

template&lt;class InputIterator, class OutputIterator, class Predicate&gt;
<span class="addition">constexpr</span> OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);

template&lt;class ForwardIterator&gt;
<span class="addition">constexpr</span> ForwardIterator unique(ForwardIterator first, ForwardIterator last);

template&lt;class ForwardIterator, class BinaryPredicate&gt;
<span class="addition">constexpr</span> ForwardIterator unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);

template&lt;class InputIterator, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result);

template&lt;class InputIterator, class OutputIterator, class BinaryPredicate&gt;
<span class="addition">constexpr</span> OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);

template&lt;class BidirectionalIterator&gt;
<span class="addition">constexpr</span> void reverse(BidirectionalIterator first, BidirectionalIterator last);

template&lt;class BidirectionalIterator, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);

template&lt;class ForwardIterator&gt;
<span class="addition">constexpr</span> ForwardIterator rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);

template&lt;class ForwardIterator, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);

// 25.3.12, shuffle:
template&lt;class RandomAccessIterator, class UniformRandomNumberGenerator&gt;
<span class="addition">constexpr</span> void shuffle(RandomAccessIterator first, RandomAccessIterator last, UniformRandomNumberGenerator&amp;&amp; g);


// 25.3.13, partitions:
template &lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);

template&lt;class ForwardIterator, class Predicate&gt;
<span class="addition">constexpr</span> ForwardIterator partition(ForwardIterator first, ForwardIterator last, Predicate pred);

template&lt;class BidirectionalIterator, class Predicate&gt;
<span class="addition">constexpr</span> BidirectionalIterator stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred);

template &lt;class InputIterator, class OutputIterator1, class OutputIterator2, class Predicate&gt;
<span class="addition">constexpr</span> pair&lt;OutputIterator1, OutputIterator2&gt;
    partition_copy(InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred);

template&lt;class ForwardIterator, class Predicate&gt;
<span class="addition">constexpr</span> ForwardIterator partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);

// 25.4, sorting and related operations:
// 25.4.1, sorting:
template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void sort(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void stable_sort(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);

template&lt;class InputIterator, class RandomAccessIterator&gt;
<span class="addition">constexpr</span> RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last);

template&lt;class InputIterator, class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);

template&lt;class ForwardIterator&gt;
<span class="addition">constexpr</span> bool is_sorted(ForwardIterator first, ForwardIterator last);

template&lt;class ForwardIterator, class Compare&gt;
<span class="addition">constexpr</span> bool is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);

template&lt;class ForwardIterator&gt;
<span class="addition">constexpr</span> ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);

template&lt;class ForwardIterator, class Compare&gt;
<span class="addition">constexpr</span> ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);

// 25.4.3, binary search:
template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class ForwardIterator, class T, class Compare&gt;
<span class="addition">constexpr</span> ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class ForwardIterator, class T, class Compare&gt;
<span class="addition">constexpr</span> ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> pair&lt;ForwardIterator, ForwardIterator&gt;
    equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class ForwardIterator, class T, class Compare&gt;
<span class="addition">constexpr</span> pair&lt;ForwardIterator, ForwardIterator&gt;
    equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);

template&lt;class ForwardIterator, class T&gt;
<span class="addition">constexpr</span> bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value);

template&lt;class ForwardIterator, class T, class Compare&gt;
<span class="addition">constexpr</span> bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value, Compare comp);

// 25.4.4, merge:
template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
<span class="addition">constexpr</span> OutputIterator merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template&lt;class BidirectionalIterator&gt;
<span class="addition">constexpr</span> void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);

template&lt;class BidirectionalIterator, class Compare&gt;
<span class="addition">constexpr</span> void inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);

// 25.4.5, set operations:
template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
<span class="addition">constexpr</span> bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
<span class="addition">constexpr</span> OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
<span class="addition">constexpr</span> OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
<span class="addition">constexpr</span> OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;
<span class="addition">constexpr</span> OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);

template&lt;class InputIterator1, class InputIterator2, class OutputIterator, class Compare&gt;
<span class="addition">constexpr</span> OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);

// 25.4.6, heap operations:
template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void push_heap(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void pop_heap(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void make_heap(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> void sort_heap(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> void sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> bool is_heap(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> bool is_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

template&lt;class RandomAccessIterator&gt;
<span class="addition">constexpr</span> RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);

template&lt;class RandomAccessIterator, class Compare&gt;
<span class="addition">constexpr</span> RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last, Compare comp);

// 25.4.7, minimum and maximum:
template&lt;class T&gt; constexpr const T&amp; min(const T&amp; a, const T&amp; b);

template&lt;class T, class Compare&gt;
constexpr const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);

template&lt;class T&gt;
constexpr T min(initializer_list&lt;T&gt; t);

template&lt;class T, class Compare&gt;
constexpr T min(initializer_list&lt;T&gt; t, Compare comp);

template&lt;class T&gt; constexpr const T&amp; max(const T&amp; a, const T&amp; b);

template&lt;class T, class Compare&gt;
constexpr const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);

template&lt;class T&gt;
constexpr T max(initializer_list&lt;T&gt; t);

template&lt;class T, class Compare&gt;
constexpr T max(initializer_list&lt;T&gt; t, Compare comp);

template&lt;class T&gt; constexpr pair&lt;const T&, const T&&gt; minmax(const T&amp; a, const T&amp; b);

template&lt;class T, class Compare&gt;
constexpr pair&lt;const T&, const T&&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);

template&lt;class T&gt;
constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);

template&lt;class T, class Compare&gt;
constexpr pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);

template&lt;class ForwardIterator&gt;
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last)

template&lt;class ForwardIterator, class Compare&gt;
constexpr ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare comp);

template&lt;class ForwardIterator&gt;
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last)

template&lt;class ForwardIterator, class Compare&gt;
constexpr ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp);

template&lt;class ForwardIterator&gt;
constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
    minmax_element(ForwardIterator first, ForwardIterator last);

template&lt;class ForwardIterator, class Compare&gt;
constexpr pair&lt;ForwardIterator, ForwardIterator&gt;
    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);

template&lt;class InputIterator1, class InputIterator2&gt;
<span class="addition">constexpr</span> bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);

template&lt;class InputIterator1, class InputIterator2, class Compare&gt;
<span class="addition">constexpr</span> bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);

// 25.4.9, permutations:
template&lt;class BidirectionalIterator&gt;
<span class="addition">constexpr</span> bool next_permutation(BidirectionalIterator first, BidirectionalIterator last);

template&lt;class BidirectionalIterator, class Compare&gt;
<span class="addition">constexpr</span> bool next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

template&lt;class BidirectionalIterator&gt;
<span class="addition">constexpr</span> bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last);

template&lt;class BidirectionalIterator, class Compare&gt;
<span class="addition">constexpr</span> bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);

}
		</pre>


		<h3>C. Modifications to remaining parts of "25 Algorithms library" [algorithms] (all sections except "Header &lt;algorithm&gt; synopsis" and "25.5 C library algorithms" [alg.c.library]) </h3>
		<p>All the functions marked with <code>constexpr</code> in previous paragraph of this document must be accordingly marked with <code>constexpr</code> in detailed algorithm description.
			For shortness only modifications to "25.2.1 All of" [alg.all_of] are shown in this paper.
		</p>
		<pre>
25.2.1 All of [alg.all_of]

template &lt;class InputIterator, class Predicate&gt;
<span class="addition">constexpr</span> bool all_of(InputIterator first, InputIterator last, Predicate pred);

Returns: true if [first,last) is empty or if pred(*i) is true for every iterator i in the range
    [first,last), and false otherwise.

Complexity: At most last - first applications of the predicate.
		</pre>


		<h3>D. Modifications to "20.2 Utility components" [utility]</h3>
		<pre>// 20.2.2, swap:
template&lt;class T&gt;
<span class="addition">constexpr</span> void swap(T&amp; a, T&amp; b) noexcept(see below );

template &lt;class T, size_t N&gt;
<span class="addition">constexpr</span> void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));

// 20.2.3, exchange:
template &lt;class T, class U=T&gt;
<span class="addition">constexpr</span> T exchange(T&amp; obj, U&amp;&amp; new_val);
		</pre>


		<h3>E. Modifications to "20.2.2 swap" [utility.swap]</h3>
		<pre>template&lt;class T&gt; <span class="addition">constexpr</span> void swap(T&amp; a, T&amp; b) noexcept(see below );

Remark: The expression inside noexcept is equivalent to:
    is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
    is_nothrow_move_assignable&lt;T&gt;::value

Requires: Type T shall be MoveConstructible (Table 20) and MoveAssignable (Table 22).
Effects: Exchanges values stored in two locations.

template&lt;class T, size_t N&gt;
<span class="addition">constexpr</span> void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));

Requires: a[i] shall be swappable with (17.6.3.2) b[i] for all i in the range [0,N).
Effects: swap_ranges(a, a + N, b)
		</pre>


		<h3>F. Modifications to "20.2.3 exchange" [utility.exchange]</h3>
		<pre>template &lt;class T, class U=T&gt; <span class="addition">constexpr</span> T exchange(T&amp; obj, U&amp;&amp; new_val);

Effects: Equivalent to:
    T old_val = std::move(obj);
    obj = std::forward&lt;U&gt;(new_val);
    return old_val;
		</pre>


		<h3>G. Feature-testing macro</h3>
		<p>For the purposes of SG10, we recommend the feature-testing macro name <code>__cpp_lib_constexpr_algorithms</code>.</p>


		<h2>V. Revision History</h2>
		<p>Revision 1:</p>
		<ul>
			<li>
				Initial proposal
			</li>
		</ul>


		<h2>VI. References</h2>
		<p>[<a name="N4567">N4567</a>] Working Draft, Standard for Programming Language C++. Available online at
					<a href="http://apolukhin.github.io/constexpr_algorithms/www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf</a></p>
		<p>[<a name="P0031R0">P0031R0</a>] A Proposal to Add Constexpr Modifiers to reverse_iterator, move_iterator, array and Range Access. Available online at
					<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html">www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0.html</a></p>
		<p>[<a name="rhalbersma">rhalbersma</a><a>] Proof of concept for some functions.
			Available online at </a><a href="https://bitbucket.org/rhalbersma/xstd/src/bbb5b04459f7b7ef02d3b6de7dfb0e90b5127177/include/xstd/algorithm.hpp">
				https://bitbucket.org/rhalbersma/xstd/src/42553df6107623c71163f104b6f3cc550c245b4b/include/xstd/algorithm.hpp</a>
			and <a href="https://bitbucket.org/rhalbersma/xstd/src/42553df6107623c71163f104b6f3cc550c245b4b/include/xstd/utility.hpp">
				https://bitbucket.org/rhalbersma/xstd/src/42553df6107623c71163f104b6f3cc550c245b4b/include/xstd/utility.hpp</a></p>
		<p>[<a name="Discussion">Discussion</a>] A call to discuss asm in constexpr and constexpr &lt;algorithm&gt;. Available online at
			<a href="https://groups.google.com/a/isocpp.org/forum/#%21topic/std-proposals/9sTJWsOpptE">https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/9sTJWsOpptE</a></p>
		<p>&nbsp;</p>

		<h2>VII. Acknowledgements</h2>
		<p>Walter E. Brown provided numerous comments, corrections, and suggestions for this proposal.</p>




</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
		<title>A Proposal to add Classes and Functions Required for Dynamic Library Load</title>
		<meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
		<meta http-equiv="Content-Language" content="en-us">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

		<style type="text/css">
			.addition { color: green; }
			.right { float:right; }
            pre { line-height: 1.2; font-size: 10pt; margin-top: 25px;}
            .desc { margin-left: 35px; margin-top: 10px; padding:0; white-space: normal; }
            body {max-width: 1024px; margin-left: 25px;}
            .cppkeyword { color: blue; }
            .cppcomment { color: green; }
            .cppcomment > .cppkeyword{ color: green; }
            .cpptext { color: #2E8B57; }
		</style>

	</head>
	<body bgcolor="#ffffff">
		<address>Document number: P0275R0</address>
		<address>Project: Programming Language C++</address>
		<address>Audience: Library Evolution Working Group</address>
		<address>&nbsp;</address>
		<address>Antony Polukhin &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;, &lt;<a href="mailto:antoshkka@yandex-team.ru">antoshkka@yandex-team.ru</a>&gt;</address>
		<address>&nbsp;</address>
		<address>Date: 2016-03-20</address>
		<h1>A Proposal to add Classes and Functions Required for Dynamic Library Load</h1>

		<h2>I. Introduction and Motivation</h2>
		<p>Adding a specific features to an existing software applications at
            runtime could be useful in many cases. Such extensions, or plugins,
            are usually implemented using Shared Library files (DLL,
            SO/DSO) loaded into the memory of program at runtime.</p>
		<p>Current C++ Standard lacks support for dynamic library 
            loading (DLL). This proposal attempts to fix that and provide a simple to
            use classes and functions for DLL.</p>
		<p>A proof of concept implementation available at: <a href="https://github.com/boostorg/dll">Boost.DLL</a>.
		</p>


		<h2>II. Impact on the Standard</h2>
		<p>This proposal is a pure library extension. It does not propose changes to
			existing headers. It relies on N4099, because it uses class experimental::path from that proposal. It does not require any changes in the core
			language and it could be implemented in standard C++.
		</p>

		<h2>III. Design Decisions</h2>
		<h3>A. Usage of <code>std::experimental::filesystem::path</code></h3>
		<p>To simplify library usage <code>std::experimental::filesystem::path</code> is used for specifying paths . All the <code>path</code> related overhead is minor,
            comparing to the time of loading shared library file into the memory of program or getting information about shared library file location.</p>
		<h3>B. Stick to the Filesystem error reporting scheme.</h3>
		<p>Provide two overloads for some functions, one that throws an exception to report system errors, and another that sets an <code>error_code</code>. This supports two common use cases:</p>
            <ul>
                <li>Uses where shared library file related system errors are truly exceptional and indicate a serious failure.</li>
                <li>Uses where shared library file related errors are routine and do not necessarily represent failure.</li>
            </ul>
		<h3>C. Do not take care of mangling.</h3>
			<p>C++ symbol mangling depend on compiler and platform. Existing attempts to get mangled symbol by unmangled name
            result in significant complexity and memory usage growth and overall slowdown of getting symbol from shared library file.
            </p>
            <pre>[Example:
    // Loading a shared library file with mangled symbols
    mangled_library lib("libmycpp.so");

    // Attempt to get function "foo::bar" with signature void(int)
    lib.get&lt;void(int)&gt;("foo::bar");

    // The problem is that we do not know what `foo::bar` is:
    // * `foo` could be a class and `bar` could be a static member function
    // * `foo` could be a struct and `bar` could be a static member function
    // * `foo` could be a namespace and `bar` could be function in that namespace
    //
    // We also do not know the calling convention for `foo` and it's noexcept specification.
    //
    // Mangling of `foo::bar` depends on all the knowledge from above, so we are either forced to
    // mangle and try to obtain all the available combinations; or we need to investigate all the
    // symbols exported by "libmycpp.so" shared library file and find a best match.
- end example]</pre>
            <p>While no good solution was found for obtaining mangled 
                symbol by unmangled name, this proposal concentrates on obtaining symbols 
                by exact name match.</p>
		<h3>D. Provide functions for simple usage.</h3>
			<p>Keeping a shared library file loaded in memory of program while using the symbol obtained from shared library file could be
            hard and error prone for some users. For the simplicity of those users, <code>import</code>
            functions were provided. Those functions return a symbol 
            wrapped in a helper class along with an instance of shared_library. In that way while
            returned value in in scope, the shared
            library file won't be unloaded from program memory, so the user does not need to take
            care of shared library file lifetime in program memory.</p>
		<h3>E. Do not search libraries in system specific paths by default.</h3>
			<p>Searching paths for a specified shared library file may affect load times and 
            make the proposed wording less efficient. It is assumed to be the most 
            common case, that
            user exactly knows were the desired shared library file is
            located and provides either absolute or relative to current
            directory path. For that case searching
            system specific paths affects performance and increases the 
            chance of finding wrong shared library file with the same name. Because some 
            operating systems search
            system paths even if relative path is provided, the 
            requirement to not do that is implicitly described in proposed wording.</p>
		<h3>F. Minimal modifications for the N4567 wording.</h3>
        <p>There have been a lot of shared library related proposals:</p>
        <ul>
        <li><a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2002/n1400.html">N1400: Toward standardization of dynamic libraries</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1418.html">N1418: Dynamic Libraries in C++</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1428.html">N1428: Draft Proposal for Dynamic Libraries in C++</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1496.html">N1496: Draft Proposal for Dynamic Libraries in C++ (Revision 1)</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1976.html">N1976: Dynamic Shared Objects: Survey and Issues</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2015.pdf" >N2015: Plugins in C++</a></li>
        <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2407.html">N2407: C++ Dynamic Library Support</a></li>
        </ul>

        <p>The proposal you're reading attempts to avoid issues of the proposals from above, minifying the changes to the N4567 wording. The proposal you're reading:</p>
        <ul>
        <li>is a pure library extension (does not modify Basic Concepts [basic] and does not add new keywords)</li>
        <li>does not add platform requiremnt for shared libraries suport</li>
        </ul>

		<h2>IV. Proposed wording relative to N4567</h2>

<h3>31 Dynamic library load support library<span class="right">[dll]</span></h3>
<h4>31.1 General <span class="right">[dll.general]</span></h4>
<p>
    'Dynamic library load' is a runtime mechanism to load shared library file into the memory of current program,
    retrieve the addresses of functions and objects contained in the shared library file, execute those functions or access those objects,
    unload the shared library file from memory.
</p>
<p>
    'Shared library file' is a file containing set of objects and functions available for use at program startup or at runtime.
</p>
<p>
    Headers &lt;experimental/dll&gt; and &lt;experimental/import&gt;
    define classes and functions suitable for dynamic library load. For
    those headers term 'symbol' relates to a
    function, reference, class member or object that can be obtained from shared library file at runtime.
    Term 'symbol name' relates to a character identifier of a symbol, using
    which symbol can be obtained from shared library file. For symbols declared with extern
    "C" in code of shared library file, 'symbol name' is the name of the
    entity. 'symbol name' without extern "C" in C++ code of shared library file
    is the mangled name of the entity.
</p>

<h4>31.2 Error reporting <span class="right">[dll.errors]</span></h4>
<p>
    Functions not having an argument of type error_code&amp; report errors as follows, unless otherwise specified:</p>
    <ul>
    <li>When a call by the implementation to an operating system or other underlying API results in an error that
    prevents the function from meeting its specifications, an exception of type system_error is thrown.</li>

    <li>Failure to allocate storage is reported by throwing an exception as described in the C++ standard,
    17.6.4.10 [res.on.exception.handling].</li>

    <li>Destructors throw nothing.</li>
    </ul>

    Functions having an argument of type error_code&amp; report errors as follows, unless otherwise specified:
    <ul>
    <li>If a call by the implementation to an operating system or other underlying API results in an 
    error that prevents the function from meeting its specifications, the error_code&amp; argument is set as
    appropriate for the specific error. Otherwise, clear() is called on the error_code&amp; argument.</li>

    <li>Failure to allocate storage is reported by throwing an exception
         as described in the C++ standard, 17.6.4.10 
        [res.on.exception.handling].</li>
    </ul>


<h4>31.3 Header &lt;experimental/dll&gt; <span class="right">[dll.dll]</span></h4>
<pre>namespace std {
  namespace experimental {
  inline namespace dll_v1 {

    // shared library file load modes
    enum class dll_mode {
        default_mode = 0,
        dont_resolve_dll_references,    // DONT_RESOLVE_DLL_REFERENCES
        load_ignore_code_authz_level,   // LOAD_IGNORE_CODE_AUTHZ_LEVEL
        rtld_lazy,                      // RTLD_LAZY
        rtld_now,                       // RTLD_NOW
        rtld_global,                    // RTLD_GLOBAL
        rtld_local,                     // RTLD_LOCAL
        rtld_deepbind,                  // RTLD_DEEPBIND
        append_decorations,             // See [dll.dll_mode]
        search_system_directories       // See [dll.dll_mode]
    };

    constexpr dll_mode  operator| (dll_mode lhs, dll_mode rhs)  noexcept;
    constexpr dll_mode&amp; operator|=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode  operator&amp; (dll_mode lhs, dll_mode rhs)  noexcept;
    constexpr dll_mode&amp; operator&amp;=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode  operator^ (dll_mode lhs, dll_mode rhs)  noexcept;
    constexpr dll_mode&amp; operator^=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
    constexpr dll_mode&amp; operator~ (dll_mode&amp; lhs) noexcept;

    // class to work with shared library files
    class shared_library;

    bool operator==(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator!=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&lt; (const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&gt; (const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&lt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;
    bool operator&gt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;

    // free functions
    template&lt;class T&gt;
    filesystem::path symbol_location(const T&amp; symbol, error_code&amp; ec);
    template&lt;class T&gt;
    boost::filesystem::path symbol_location(const T&amp; symbol);

    filesystem::path this_line_location(error_code&amp; ec);
    filesystem::path this_line_location();

    filesystem::path program_location(error_code&amp; ec);
    filesystem::path program_location();

  }
  }

  // support
  template &lt;class T&gt; struct hash;
  template &lt;&gt; struct hash&lt;experimental::shared_library&gt;;
  template &lt;&gt; struct hash&lt;experimental::dll_mode&gt;;
}

</pre>
<p>
The value of each enum dll_mode constant shall be the same as the value 
of the macro shown in the above synopsis if that macro is available on 
the platform or 0 otherwise.
</p>

<h4>31.3.1 Enum dll_mode <span class="right">[dll.dll_mode]</span></h4>
<p>
    Enum dll_mode provides modes for searching the shared library file and platform specific modes for loading the shared library file in memory of program.
    [Note: library users may extend available modes by
    casting the required platform specific mode to dll_mode: <i>[ Example:</i> <code>static_cast&lt;dll_mode&gt;(RTLD_NODELETE); </code><i> — end example ] — end note ]</i></p>

<p>
    Each of system family 
    provides own modes, flags not supported by a particular platform must be
    set to 0. Special modes are listened below:
</p>

<pre>append_decorations</pre>
    <div class="desc"><i>Effects:</i> Appends a platform specific extensions and prefixes to shared library filename before trying to load it into program memory.
    If load attempts fail, tries to load with exactly specified name.</div>
    <div class="desc"><i>Platforms:</i> Windows, POSIX</div>
    <div class="desc"><i>Value:</i> Any value that can not be received by applying binary OR to any set of modes from dll_mode</div>
    <div class="desc"><i>[Example:</i></div>
<pre>        // Tries to open
        //      `./my_plugins/plugin1.dll` and `./my_plugins/libplugin1.dll` on Windows
        //      `./my_plugins/libplugin1.so` on Linux
        //      `./my_plugins/libplugin1.dylib` and `./my_plugins/libplugin1.so` on MacOS.
        // If that fails, loads `./my_plugins/plugin1`
        shared_library lib("./my_plugins/plugin1", dll_mode::append_decorations);
- end example]</pre>

<pre>default_mode</pre>
    <div class="desc"><i>Effects:</i> Default mode for a particular platform.</div>

<pre>search_system_directories</pre>
    <div class="desc"><i>Value:</i> Any value that can not be received by applying binary OR to any set of modes from dll_mode</div>
    <div class="desc"><i>Effects:</i> Allows loading of shared library files from system specific shared library file directories [fs.def.directory]
    along with loading shared library files from current directory.</div>


<h4>31.3.1.1 dll_mode operators <span class="right">[dll.dll_mode.operators]</span></h4>
<pre>constexpr dll_mode  operator| (dll_mode lhs, dll_mode rhs)  noexcept;
constexpr dll_mode&amp; operator|=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
constexpr dll_mode  operator&amp; (dll_mode lhs, dll_mode rhs)  noexcept;
constexpr dll_mode&amp; operator&amp;=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
constexpr dll_mode  operator^ (dll_mode lhs, dll_mode rhs)  noexcept;
constexpr dll_mode&amp; operator^=(dll_mode&amp; lhs, dll_mode rhs) noexcept;
constexpr dll_mode&amp; operator~ (dll_mode&amp; lhs) noexcept;</pre>
    <div class="desc"><i>Effects:</i> Converts parameters to unsigned integral type capable of storing them, applies a corresponding
    binary operator and returns the result as dll_mode.</div>

<h4>31.3.1.2 dll_mode hash support<span class="right">[dll.dll_mode.hash]</span></h4>
<pre>template &lt;&gt; struct hash&lt;experimental::dll_mode&gt;;
</pre>
<p>
    The template specialization shall meet the requirements of class template hash (20.9.13).
</p>


<h4>31.3.2 Class shared_library <span class="right">[dll.shared_library]</span></h4>
<p>
    The class shared_library provides means to load shared library file into the memory of program,
    check that shared library file exports symbol with specified symbol name and obtain that
    symbol.
</p>
<p>
    shared_library instances share reference count to an actual shared library file loaded in memory
    of current program, so it is safe and memory efficient to have multiple instances
    of shared_library referencing the same shared library file even if those instances 
    were loaded in memory using different paths (relative and absolute) referencing the
    same shared library file.
</p>
<p>
    It must be safe to concurrently load shared library files into memory of program, unload and get symbols from
    any shared library files using different shared_library instances. If current
    platform does
    not guarantee safe concurrent work with shared library files, calls to shared_library functions must
    be serialized by shared_library implementation.
</p>
<p>
    [ Note: Constructors, comparisons and reset() functions that accept nullptr_t are not provided because that may cause confusion:
    some of the platforms provide interfaces for shared library files that accept nullptr_t to get a handler to the current program. — end note ]
</p>
<pre>namespace std {
  namespace experimental {
  inline namespace dll_v1 {

    class shared_library {
    public:
      typedef platform_specific native_handle_type;

      // construct/copy/destruct
      shared_library() noexcept;
      shared_library(const shared_library&amp; lib);
      shared_library(const shared_library&amp; lib, error_code&amp; ec);
      shared_library(shared_library&amp;&amp; lib) noexcept;
      explicit shared_library(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
      shared_library(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
      shared_library(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);
      ~shared_library();

      // public member functions
      shared_library&amp; assign(const shared_library&amp; lib, error_code&amp; ec);
      shared_library&amp; assign(const shared_library&amp; lib);
      
      shared_library&amp; operator=(const shared_library&amp; lib);
      shared_library&amp; operator=(shared_library&amp;&amp; lib) noexcept;

      void load(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
      void load(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
      void load(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);

      void reset() noexcept;
      explicit operator bool() const noexcept;

      bool has(const char* symbol_name) const noexcept;
      bool has(const string&amp; symbol_name) const noexcept;

      template &lt;typename SymbolT&gt;
      auto get(const char* symbol_name) const
        -&gt; conditional_t&lt;is_member_pointer_v&lt;SymbolT&gt;, SymbolT, add_lvalue_reference_t&lt;SymbolT&gt;&gt;;

      template &lt;typename SymbolT&gt;
      auto get(const string&amp; symbol_name) const
        -&gt; conditional_t&lt;is_member_pointer_v&lt;SymbolT&gt;, SymbolT, add_lvalue_reference_t&lt;SymbolT&gt;&gt;;

      native_handle_type native_handle() const noexcept;

      filesystem::path location() const;
      filesystem::path location(error_code&amp; ec) const;

      // public static member functions
      static constexpr bool platform_supports_dll() noexcept;
      static constexpr bool platform_supports_dll_of_program() noexcept;
    };

  }
  }
}
</pre>

<h4>31.3.3.1 shared_library constructors <span class="right">[dll.shared_library.constr]</span></h4>
<pre>shared_library() noexcept;</pre>
    <div class="desc"><i>Effects:</i> Creates shared_library that does not reference any shared library file.</div>
    <div class="desc"><i>Postconditions:</i> *this is false.</div>

<pre>shared_library(const shared_library&amp; lib);
shared_library(const shared_library&amp; lib, error_code&amp; ec);</pre>
    <div class="desc"><i>Effects:</i> Makes *this reference the same shared library file that is referenced by lib or if lib does not reference shared library file
    sets *this to default constructed state.</div>
    <div class="desc"><i>Postconditions:</i> lib == *this</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>

<pre>shared_library(shared_library&amp;&amp; lib) noexcept;</pre>
    <div class="desc"><i>Effects:</i> Assigns the state of lib to *this and sets lib to a default constructed state.</div>
    <div class="desc"><i>Remarks:</i> Does not invalidate symbols previously obtained from lib.</div>
    <div class="desc"><i>Postconditions:</i> lib is false, *this is true.</div>

<pre>explicit shared_library(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
shared_library(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
shared_library(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);</pre>
    <div class="desc"><i>Effects:</i> Same as calling shared_library::load() with same parameters.</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors].</div>


<h4>31.3.3.2 shared_library destructor <span class="right">[dll.shared_library.destr]</span></h4>
<pre>~shared_library();</pre>
<div class="desc">
    <i>Effects:</i> Destroys the shared_library by calling reset(). If
    the shared library file is referenced by different instances of
    shared_library,
    the shared library file won't be unloaded until there is at least one 
    instance of shared_library referencing it.
</div>



<h4>31.3.3.3 shared_library members<span class="right">[dll.shared_library.member]</span></h4>
<pre>shared_library&amp; assign(const shared_library&amp; lib, error_code&amp; ec);
shared_library&amp; assign(const shared_library&amp; lib);</pre>
    <div class="desc"><i>Effects:</i> If *this, then calls reset().
    Makes *this reference the same shared library file as lib.</div>
    <div class="desc"><i>Postconditions:</i> lib.location() == this-&gt;location(), lib == *this</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>
    
<h4>31.3.3.4 shared_library assignment <span class="right">[dll.shared_library.assign]</span></h4>
<pre>shared_library&amp; operator=(const shared_library&amp; lib);</pre>
    <div class="desc"><i>Effects:</i> Same as calling this-&gt;assign(lib)</div>

<pre>shared_library&amp; operator=(shared_library&amp;&amp; lib) noexcept;</pre>
    <div class="desc"><i>Effects:</i> If *this then calls
 this-&gt;reset(). Assigns the state of lib to *this and sets lib 
to a default constructed state.</div>
    <div class="desc"><i>Remarks:</i> Does not invalidate symbols previously obtained from lib.</div>
    <div class="desc"><i>Postconditions:</i> lib is false, *this is true.</div>


<pre>void load(const filesystem::path&amp; library_path, dll_mode mode = dll_mode::default_mode);
void load(const filesystem::path&amp; library_path, error_code&amp; ec, dll_mode mode = dll_mode::default_mode);
void load(const filesystem::path&amp; library_path, dll_mode mode, error_code&amp; ec);</pre>
    <div class="desc"><i>Effects:</i> If the shared library file specified by library_path is already loaded in memory of current program
    makes *this reference the previously loaded shared library file.
    Otherwise loads a shared library file by specified path with a specified mode into the memory of current program,
    executes all the platform specific initializations
    and makes the symbols of that shared library file ready to obtain using this->get().
    If some shared library file is already referenced by *this, calls reset() first.</div>

    <div class="desc">Must be capable of referencing current program if
    absolute or relative path to the program was provided as
    library_path. Must try to load
    shared library file with changed name and applied extension only if (mode &amp; 
    dll_mode::append_decorations) is not 0. Must
    attempt to load a shared library file from system specific shared library file
    directories only if library_path contains only shared library filename and
    (mode &amp; dll_mode::search_system_directories) is not 0. During loads
    from system
    specific directories file name modification rules from above apply. If
    with dll_mode::search_system_directories more than one
    shared library file has the same base name and extension, the function
    loads in memory any first matching shared library file.
    If (mode &amp; dll_mode::search_system_directories) is 0, then any 
    relative path or path that contains only filename must be treated as a
    path in current working directory.</div>

    <div class="desc">Library open mode is equal to (mode &amp; 
    ~dll_mode::search_system_directories &amp; ~dll_mode::append_decorations) 
    converted to a platform specific
    type representing shared library file load modes and adjusted to satisfy the 
    dll_mode::search_system_directories requirements from above. If mode is
    invalid for current platform, attempts to adjust the mode by 
    applying dll_mode::rtld_lazy
    and throws if resulting mode is invalid. <i>[Example:</i> If mode on POSIX was set to rtld_local, then it will be adjusted
    to rtld_lazy | rtld_local. - end example]</div>

    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>

<pre>void reset() noexcept;</pre>
    <div class="desc"><i>Effects:</i> Sets *this to a default constructed state. If *this was the last instance of shared_library referencing the shared library file,
    then all the resources associated with shared library file shall be released.</div>
    <div class="desc"><i>Remarks:</i> Symbols obtained from shared library file remain valid until there is at least one instance of shared_library referencing the shared library file.</div>
    <div class="desc"><i>Postconditions:</i> *this is false.</div>

<pre>explicit operator bool() const noexcept;</pre>
    <div class="desc"><i>Returns:</i> true if *this references a shared library file.</div>

<pre>bool has(const char* symbol_name) const noexcept;
bool has(const string&amp; symbol_name) const noexcept;</pre>
    <div class="desc"><i>Returns:</i> true if *this references a shared library file and symbol symbol_name could be obtained from shared library file.</div>

<pre>template &lt;typename SymbolT&gt;
auto get(const char* symbol_name) const
    -&gt; conditional_t&lt;is_member_pointer_v&lt;SymbolT&gt;, SymbolT, add_lvalue_reference_t&lt;SymbolT&gt;&gt;;

template &lt;typename SymbolT&gt;
auto get(const string&amp; symbol_name) const
    -&gt; conditional_t&lt;is_member_pointer_v&lt;SymbolT&gt;, SymbolT, add_lvalue_reference_t&lt;SymbolT&gt;&gt;;</pre>
    <div class="desc"><i>Returns:</i> Symbol from shared library file that has the name symbol_name.</div>
    <div class="desc"><i>Remarks:</i> It's the user responsibility to 
    provide valid SymbolT type for symbol. However implementations may 
    provide additional checks for
    matching SymbolT type and actual symbol type. [ Note: For
    example implementations
    may check that SymbolT is a function pointer and that
    symbol with symbol_name allows execution. — end note ]</div>
    <div class="desc"><i>Throws:</i> system_error if symbol does not exist or if the shared library file was not loaded.</div>

<pre>native_handle_type native_handle() const noexcept;</pre>
    <div class="desc"><i>Returns:</i> Native handler of the loaded in memory shared library file or default constructed native_handle_type if *this does not reference a shared library file.
    [ Note: This member allow implementations to provide access to implementation details. Actual use of these members is inherently non-portable. — end note ]
</div>

<pre>filesystem::path location() const;
filesystem::path location(error_code&amp; ec) const;</pre>
    <div class="desc"><i>Returns:</i> Full path and name to the referenced shared library file, throws if *this does not reference shared library file.</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>

<h4>31.3.3.5 shared_library static members<span class="right">[dll.shared_library.static]</span></h4>

<pre>static constexpr bool platform_supports_dll() noexcept;</pre>
    <div class="desc"><i>Returns:</i> true if platform supports loading of shared library files into the momery of program.
    [ Note: If this function returns false, then any attempt to load a shared library file will fail at runtime. This function could be used to ensure platform capabilities at
    compile time: <code>static_assert(shared_library::platform_supports_dll(), "DLL required for this program");</code> — end note ]</div>


<pre>static constexpr bool platform_supports_dll_of_program() noexcept</pre>
    <div class="desc"><i>Returns:</i> true if according to platform capabilities <code>shared_library(program_location())</code> may succeed.</div>


<h4>31.3.3.6 shared_library free operators<span class="right">[dll.shared_library.operators]</span></h4>
<p>
    shared_library provides fast comparison operators that compare the referenced shared libraries file.
</p>
<pre>bool operator==(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() == rhs.native_handle()</div>

<pre>bool operator!=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() != rhs.native_handle()</div>

<pre>bool operator&lt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() &lt; rhs.native_handle()</div>

<pre>bool operator&gt;(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() &gt; rhs.native_handle()</div>

<pre>bool operator&lt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() &lt;= rhs.native_handle()</div>

<pre>bool operator&gt;=(const shared_library&amp; lhs, const shared_library&amp; rhs) noexcept;</pre>
    <div class="desc"><i>Returns:</i> lhs.native_handle() &gt;= rhs.native_handle()</div>


<h4>31.3.3.7 shared_library hash support<span class="right">[dll.shared_library.hash]</span></h4>
<pre>template &lt;&gt; struct hash&lt;experimental::shared_library&gt;;</pre>
    <div class="desc">The template specialization shall meet the requirements of class template hash (20.9.13).</div>


<h4>31.3.4 Runtime path functions<span class="right">[dll.location]</span></h4>
<pre>template&lt;class T&gt;
filesystem::path symbol_location(const T&amp; symbol, error_code&amp; ec);
template&lt;class T&gt;
boost::filesystem::path symbol_location(const T&amp; symbol);</pre>
    <div class="desc"><i>Returns:</i> Full path and name to shared library file or program that contains symbol</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>

<pre>filesystem::path this_line_location(error_code&amp; ec);
filesystem::path this_line_location();</pre>
    <div class="desc"><i>Returns:</i> Full path and name to shared library file or program that contains line of code in which this_line_location() was called</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>

<pre>filesystem::path program_location(error_code&amp; ec);
filesystem::path program_location();</pre>
    <div class="desc"><i>Returns:</i> Full path and name to the current program.</div>
    <div class="desc"><i>Throws:</i> As specified in [dll.errors]</div>


<h4>31.4 Header &lt;experimental/import&gt; <span class="right">[dll.import.header]</span></h4>
<pre>#include &lt;experimental/dll&gt;
#include &lt;type_traits&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

namespace std {
  namespace experimental {
  inline namespace dll_v1 {

    template &lt;typename SymbolT&gt;
    using imported_t = conditional_t&lt;is_object_v&lt;SymbolT&gt;, shared_ptr&lt;SymbolT&gt;, function&lt;SymbolT&gt;&gt;;

    // functions for importing a symbol
    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const char* symbol_name, dll_mode mode = dll_mode::default_mode);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const string&amp; symbol_name, dll_mode mode = dll_mode::default_mode);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const char* symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const string&amp; symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const char* symbol_name);

    template &lt;typename SymbolT&gt;
    imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const string&amp; symbol_name);

  }
  }
}
</pre>

<p>import functions are meant to simplify dynamic library loads of
    symbols by keeping shared library file loaded in program memory while imported symbol is in scope:</p>
<pre>[Example:
    // Code of "/plugin_directory/libplugin.so" contains extern "C" void foo_function(string&amp;&amp;)

    auto foo_function = import&lt;void(string&amp;&amp;)&gt;("/plugin_directory/libplugin.so", "foo_function");
    foo_function("Test");
- end example]</pre>


<h4>31.4.1 import functions <span class="right">[dll.import.func]</span></h4>
<pre>template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const char* symbol_name, dll_mode mode = dll_mode::default_mode);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const filesystem::path&amp; library_path, const string&amp; symbol_name, dll_mode mode = dll_mode::default_mode);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const char* symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(const shared_library&amp; library, const string&amp; symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const char* symbol_name);

template &lt;typename SymbolT&gt;
imported_t&lt;SymbolT&gt; import(shared_library&amp;&amp; library, const string&amp; symbol_name);</pre>
    <div class="desc"><i>Effects:</i> Obtains a symbol with name symbol_name from shared library file and returns it wrapped in class that implements semantics
    of shared ownership of shared library file; the last remaining owner is responsible for releasing the resources associated with the
    shared library file. mode must be passed to shared_library constructor or shared_library::load function.</div>
    <div class="desc"><i>Remarks:</i> It's the user responsibility to provide valid SymbolT type for symbol.</div>
    <div class="desc"><i>Return type:</i> imported_t&lt;SymbolT&gt; that keeps an instance an of shared_library internally</div>
    <div class="desc"><i>Returns:</i> Variable that keeps shared_library and symbol and provides access to the symbol only.</div>
    <div class="desc"><i>Throws:</i> system_error if symbol does not exist or if failed to load the shared library file into the memory of program.</div>


		<h2>V. Feature-testing macro</h2>
		<p>For the purposes of SG10 it is sufficient to check for header 
        &lt;experimental/dll&gt; or &lt;experimental/import&gt; using 
        __has_include.
        </p>


		<h2>V. Revision History</h2>
		<p>Revision 0:</p>
		<ul>
			<li>
				Initial proposal
			</li>
		</ul>


		<h2>VI. References</h2>
		<p>[<a name="Boost.DLL">Boost.DLL</a>] Boost DLL library.
			Available online at <a href="https://github.com/boostorg/dll">https://github.com/boostorg/dll</a></p>
		<p>[<a name="N4567">N4567</a>] Working Draft, Standard for Programming Language C++.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf</a></p>
		<p>[<a name="N4099">N4099</a>] Working Draft, Technical Specification — File System.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4099.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4099.html</a></p>


		<p>[<a name="N1400">N1400</a>] Toward standardization of dynamic libraries.
			Available online at <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2002/n1400.html">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2002/n1400.html</a></p>
		<p>[<a name="N1418">N1418</a>] Dynamic Libraries in C++.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1418.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1418.html</a></p>
		<p>[<a name="N1428">N1428</a>] Draft Proposal for Dynamic Libraries in C++.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1428.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1428.html</a></p>
		<p>[<a name="N1496">N1496</a>] Draft Proposal for Dynamic Libraries in C++ (Revision 1).
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1496.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1496.html</a></p>
		<p>[<a name="N1976">N1976</a>] Dynamic Shared Objects: Survey and Issues.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1976.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1976.html</a></p>
		<p>[<a name="N2015">N2015</a>] Plugins in C++.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2015.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2015.pdf</a></p>
		<p>[<a name="N2407">N2407</a>] C++ Dynamic Library Support.
			Available online at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2407.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2407.html</a></p>
		<p>&nbsp;</p>

		<h2>VII. Acknowledgements</h2>
		<p>Klemens Morgenstern highlighted some of the missing functionality 
        in Boost.DLL and provided implementation of mangled symbols load,
        that showed complexities of such approach. Renato Tegon Forti started the work on Boost.DLL and
        provided a lot of code, help and documentation for the Boost.DLL.</p>



        <script type="text/javascript">
            function colorize_texts(texts) {
                for (var i = 0; i < texts.length; ++i) {
                    var text = texts[i].innerHTML;
                    text = text.replace(/namespace|enum|void|constexpr|noexcept|bool|template|class|struct|auto|const|typename|explicit|public|private|operator|#include|char|typedef|static_assert|static_cast|static/g,"<span class='cppkeyword'>$&</span>");
                    text = text.replace(/\/\/[\s\S]+?\n/g,"<span class='cppcomment'>$&</span>");
                    text = text.replace(/\"[\s\S]+?\"/g,"<span class='cpptext'>$&</span>");
                    texts[i].innerHTML = text;
                }
            }

            colorize_texts(document.getElementsByTagName("pre"));
            colorize_texts(document.getElementsByTagName("code"));
        </script>


</body></html>

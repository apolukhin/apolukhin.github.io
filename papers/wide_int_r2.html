<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
        <title>A Proposal to add wide_int Class</title>
        <meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
        <meta http-equiv="Content-Language" content="en-us">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <style type="text/css">
            .addition { color: green; }
            .right { float:right; }
            .changed-deleted { background-color: #CFF0FC ; text-decoration: line-through; display: none; }
            .addition.changed-deleted { color: green; background-color: #CFF0FC ; text-decoration: line-through; text-decoration: black double line-through; display: none; }
            .changed-added { background-color: #CFF0FC ;}
            .notes { background-color: #80D080 ;}
            pre { line-height: 1.2; font-size: 10pt; margin-top: 25px; }
            .desc { margin-left: 35px; margin-top: 10px; padding:0; white-space: normal; }
            body {max-width: 1024px; margin-left: 25px;}
            .cppkeyword { color: blue; }
            .cppcomment { color: green; }
            .cppcomment > .cppkeyword{ color: green; }
            .cpptext { color: #2E8B57; }
        </style>
    </head>
    <body bgcolor="#ffffff">
        <address>Document number: P0539R2</address>
        <address>Project: Programming Language C++</address>
        <address>Audience: SG6 Numerics</address>
        <address>&nbsp;</address>
        <address>Igor Klevanets &lt;<a href="mailto:cerevra@yandex.ru">cerevra@yandex.ru</a>&gt;, &lt;<a href="mailto:cerevra@yandex-team.ru">cerevra@yandex-team.ru</a>&gt;</address>
        <address>Antony Polukhin &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;, &lt;<a href="mailto:antoshkka@yandex-team.ru">antoshkka@yandex-team.ru</a>&gt;</address>
        <address>&nbsp;</address>
        <address>Date: 2017-10-10</address>
        <h1>A Proposal to add wide_int Template Class</h1>

        <p class="changed-added">Significant changes to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0539r1.html">P0539R1</a> are marked with blue.</p><p>
        <!--p><input type="checkbox" id="show_deletions" onchange="show_hide_deleted()"/> Show deleted lines from P0275R1.</p-->
        </p><p class="notes">Green lines are notes for the <b>editor</b> or for the <b>SG6</b> that must not be treated as part of the wording.</p>
        <h2>I. Introduction and Motivation</h2>
        <p>Current standard provides signed and unsigned int8_t, 
int16_t, int32_t, int64_t. It is usually enough for every day tasks, but
 sometimes appears a need in big numbers: for cryptography, IPv6, very 
big counters etc. Non-standard type __int128 which is provided by gcc 
and clang illuminates this need. But there is no cross-platform solution
 and no way to satisfy future needs in even more big numbers.</p>
        <p>This is an attempt to solve the problem in a generic way on a library level and provide wording for <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0104r0.html">P0104R0: Multi-Word Integer Operations and Types</a>.</p>
        <p>A proof of concept implementation available at: <a href="https://github.com/cerevra/int/tree/master/v3">https://github.com/cerevra/int/tree/master/v3</a>.
        </p>

        <h2>II. Changelog</h2>
        <p class="changed-added">Differences with P0539R1:</p>
        <ul class="changed-added">
            <li>Added a discussion on "Words vs Bytes vs Bits"</li>
        </ul>
        <p>Differences with P0539R0:</p>
        <ul>
            <li>Reworked the proposal for simpler integration with other Numerics proposals:
            <ul>
                <li>Added an interoperability section [numeric.interop]</li>
                <li><code>Arithmetic</code> and <code>Integral</code> concepts were moved to [numeric.requirements] as they seem widely useful</li>
                <li>Binary non-member operations that accept <code>Arithmetic</code> or <code>Integral</code> parameter were changed to accept two <code>Arithmetic</code> or <code>Integral</code> parameters respectively and moved to [numeric.interop]</li>
                <li><code>int128_t</code> and other aliases now depend on <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0102r0.html">P0102R0</a></li>
            </ul>
            </li>
            <li>Renamed <code>wide_int</code> to <code>wide_integer</code></li>
            <li><code>wide_integer</code> now uses machine words count as a template parameter, not bits count</li>
            <li>Removed not allowed type traits specializations</li>
            <li>Added <code>to_chars</code> and <code>from_chars</code></li>
        </ul>


        <h2 class="changed-added">III. Discussion about the way to set the wide_integer size</h2>
        <div class="changed-added">
        <p>In this proposal we would like to concentrate on the <code>wide_integer</code> class that uses machine words under the cover. Such implementations allow you to get best performance
        and leave behind some design questions, like "Is <code>(<span class="cppkeyword">sizeof</span>(wide_integer&lt;X&gt;)&nbsp;==&nbsp;X&nbsp;/&nbsp;CHAR_BITS)</code> or not?".</p>
        <p>However, we do not wish to shut the door close for extending the abilities of the <code>wide_integer</code> class. Some users may wish to see unit40_t, or unit48_t.</p>
        <p>We insist on <b>interface that allows specifying integers not representable by machine words count</b>. Such extensions of functionality may be discussed in separate papers.</p>

        <p class="notes"><b><i>[Note to SG6:</i></b> The "Words vs Bytes vs Bits" interface problem seems to rise very often. It may be worth discussing it in a bigger group
        or at least discuss it after the remaining parts of the paper are tentatively accepted. <i><b>- end note]</b></i></p>

        <p>There are several possible meanings of the first template argument of wide_integer:</p>
        <ul>
          <li>Number of machine words</li>
          <li>Number of bytes</li>
          <li>Number of bits</li>
        </ul>
        <p>Where number must be:</p>
        <ul>
          <li>Power of 2</li>
          <li>Or such as <code><span class="cppkeyword">sizeof</span>(wide_integer)</code> is multiply of <code><span class="cppkeyword">sizeof</span>(<i>machine word</i>)</code></li>
        </ul>

        <p>As was noted above, we would like to use <i>machine words</i> under the hood, but we would like to avoid any mention of <i>machine words</i> in the interface.
        Machine word is a strong restriction for interface, which does not allow to extend functionality in the future.</p>

        <p>"Power of 2" restriction seems over restrictive. If <i>machine word</i> is 32 bits users may wish to have <code>uint96_t</code>.
        Supporting such type is quite easy.</p>

        <p>So the actual choice can be <b>Bytes</b> or <b>Bits</b> where <code><span class="cppkeyword">sizeof</span>(wide_integer)</code> is multiply of <code><span class="cppkeyword">sizeof</span>(<i>machine word</i>)</code>.</p>
        <p>Pros and cons for Bits vs Bytes:</p>
        <ul>
          <li>x86 users are used to <b>Bits</b> due to wide usage of <code>&lt;cmath&gt;</code> aliases like <code>uint32_t</code>.</li>
          <li>Bytes hide the actual bits count. When x86 user specifies 16 bytes he probably wishes to get 128 <b>Bits</b>, not <code>CHAR_BITS * 16</code> bits.</li>
          <li><b>Bytes</b> are preferable for platforms that have <code>CHAR_BITS % 8 != 0</code>, because code with specified bits may not compile for such platform:
          <pre><span class="cppkeyword">void</span> foo(wide_uint&lt;128&gt; ); // OK on x86, does not compile if CHAR_BITS == 9</pre>
          </li>
        </ul>
        <p>There was also an idea to provide a way for a user to replace
 the underlying type that represents machine word (allow to specify <code>unsigned int</code> or <code><span class="cppkeyword">long</span></code> or
        <code><span class="cppkeyword">long</span> <span class="cppkeyword">long</span></code>). Such idea seems to unnecessary complicate the interface and expose the internals of the <code>wide_integer</code> type. We assume that the decision must be done by
        the library implementor rather than by user.</p>
        </div>

        <h2>IV. Proposed wording</h2>


<p class="notes"><b><i>[Note to SG6:</i></b> Following 4 paragraphs affect <b>all</b> the new numeric class proposals. <i><b>- end note]</b></i></p>

<h3>18.3.4 Class template numeric_limits<span class="right">[numeric.limits]</span></h3>
<p class="notes"><b><i>[Note to editor:</i></b> Add the following 
sentence after the sentence "Specializations shall be provided for each 
arithmetic type, both floating-point and integer, including bool." 
(first sentence in fourth paragraph in [numeric.limits]) <i><b>- end note]</b></i></p>
<p>Specializations shall be also provided for <code>wide_integer</code> type. <i>[Note:</i> If there is a built-in integral type <code>Integral</code> that has the same signedness and width as <code>wide_integer&lt;MachineWords, S&gt;</code>, then <code>numeric_limits&lt;wide_integer&lt;MachineWords, S&gt;&gt;</code> specialized in the same way as <code>numeric_limits&lt;Integral&gt;</code><i>- end note]</i> </p>

<h3>26.2 Definitions<span class="right">[numerics.defns]</span></h3>
<p class="notes"><b><i>[Note to editor:</i></b> Add the following paragraph to the end of [numerics.defns] <i><b>- end note]</b></i></p>
<p>Define <code>CT</code> as <code>common_type_t&lt;A, B&gt;</code>, where <code>A</code> and <code>B</code> are the types of the two function arguments.</p>


<h3>26.3 Numeric type requirements<span class="right">[numeric.requirements]</span></h3>
<p class="notes"><b><i>[Note to editor:</i></b> Add the following paragraphs to the end of [numeric.requirements] <i><b>- end note]</b></i></p>
<p>Functions that accept template parameters starting with <code>Arithmetic</code> shall not participate in overload resolution unless <code>std::numeric_limits&lt;Arithmetic&gt;::is_specialized</code> is true.</p>
<p>Functions that accept template parameters starting with <code>Integral</code> shall not participate in overload resolution unless <code>std::numeric_limits&lt;Integral&gt;::is_integer</code> is true.</p>


<h3>26.4 Numeric types interoperability<span class="right">[numeric.interop]</span></h3>
<div>

<p class="notes"><b><i>[Note to SG6:</i></b> This is an early attempt to make it possible for different numeric types to inter-operate. It works for <code>wide_integer<i> and </i>built-in types</code>, but this approach requires additional study and <code>common_type</code> fixes for new <code>Arithmetic</code> types. <i><b>- end note]</b></i></p>


<p>Following operators are defined for types <code>T</code> and <code>U</code> if <code>T</code> and <code>U</code> have a defined <code>common_type_t&lt;T, U&gt;</code> and satisfy the <code>Arithmetic</code> or <code>Integral</code> requirements from [numeric.requirements] <i>[Note:</i> Implementations are encouraged to provide optimized specializations of the following operators <i>- end note]</i>:</p>

<p class="notes"><b><i>[Note to SG6:</i></b> We may add to <code>Arithmetic</code> and <code>Integral</code> concepts additional requirement that <code>std::numeric_limits&lt;<i>Integral-or-Arithmetic</i>&gt;::is_interoprable</code>
 shall be true. In that case no user code will be broken even if user 
already added following operators. However this seems to be an overkill.
 <i><b>- end note]</b></i></p>


<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  common_type_t&lt;Arithmetic1, Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>*(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) * CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  common_type_t&lt;Arithmetic1, Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>/(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) / CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  common_type_t&lt;Arithmetic1, Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>+(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) + CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  common_type_t&lt;Arithmetic1, Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>-(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) - CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, Integral2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>%(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) % CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, Integral2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&amp;(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &amp; CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, Integral2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>|(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) | CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, Integral2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>^(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) ^ CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, size_t&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&lt;&lt;(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>common_type_t&lt;Integral1, size_t&gt;(lhs) &lt;&lt; <span class="cppkeyword">static_cast</span>&lt;size_t&gt;(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral1, <span class="cppkeyword">typename</span> Integral2&gt;
  common_type_t&lt;Integral1, size_t&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&gt;&gt;(<span class="cppkeyword">const</span> Integral1&amp; lhs, <span class="cppkeyword">const</span> Integral2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>common_type_t&lt;Integral1, size_t&gt;(lhs) &gt;&gt; <span class="cppkeyword">static_cast</span>&lt;size_t&gt;(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &lt; CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &gt; CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;=(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &lt;= CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;=(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &gt;= CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>==(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) == CT(rhs)</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic1, <span class="cppkeyword">typename</span> Arithmetic2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>!=(<span class="cppkeyword">const</span> Arithmetic1&amp; lhs, <span class="cppkeyword">const</span> Arithmetic2&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>!(lhs == rhs)</code>.</div>


</div>







<h3>26.??.1 Header &lt;wide_integer&gt; synopsis<span class="right">[numeric.wide_integer.syn]</span></h3>
<pre><span class="cppkeyword">namespace</span> std {
  <span class="cppkeyword">enum</span> <span class="cppkeyword">class </span>signedness {
      Unsigned,
      Signed
  };

  <span class="notes"><b><i>[Note to SG6:</i></b> We leave <code>MachineWords</code> in the interface until the "Words vs Bytes vs Bits" interface problem is not solved. <i><b>- end note]</b></i></span>
  <span class="cppcomment">// 26.??.2 <span class="cppkeyword">class </span><span class="cppkeyword">template</span> wide_integer
</span>  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">class </span>wide_integer;

  <span class="cppcomment">// 26.??.?? type traits specializations
</span>  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">struct</span> common_type&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, <span class="cppkeyword">typename</span> Arithmetic&gt;
  <span class="cppkeyword">struct</span> common_type&lt;wide_integer&lt;MachineWords, S&gt;, Arithmetic&gt;;

  <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic, size_t MachineWords, signedness S&gt;
  <span class="cppkeyword">struct</span> common_type&lt;Arithmetic, wide_integer&lt;MachineWords, S&gt;&gt;
    : common_type&lt;wide_integer&lt;MachineWords, S&gt;, Arithmetic&gt;
  ;

  <span class="cppcomment">// 26.??.?? unary operations
</span>  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>~(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>;
  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>-(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>+(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned)<span class="changed-added"> <span class="cppkeyword">noexcept</span></span>;

  <span class="cppcomment">// 26.??.?? binary operations
</span>  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>*(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>/(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>+(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>-(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>%(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&amp;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>|(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
    <span class="cppkeyword">constexpr</span>  <span class="cppkeyword">operator</span>^(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, size_t&gt;
    <span class="cppkeyword">constexpr</span>  <span class="cppkeyword">operator</span>&lt;&lt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, size_t rhs);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt;
    common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, size_t&gt;
    <span class="cppkeyword">constexpr</span>  <span class="cppkeyword">operator</span>&gt;&gt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, size_t rhs);

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>==(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>!=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;

  <span class="cppcomment">// 26.??.?? numeric conversions
</span>  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; std::string to_string(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);
  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; std::wstring to_wstring(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);

  <span class="cppcomment">// 26.??.?? iostream specializations
</span>  <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>Char, <span class="cppkeyword">class </span>Traits, size_t MachineWords, signedness S&gt;
  basic_ostream&lt;Char, Traits&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;(basic_ostream&lt;Char, Traits&gt;&amp; os, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);

  <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>Char, <span class="cppkeyword">class </span>Traits, size_t MachineWords, signedness S&gt;
  basic_istream&lt;Char, Traits&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;(basic_istream&lt;Char, Traits&gt;&amp; is, wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>;

  <span class="cppcomment">// 26.??.?? hash support
</span>  <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>T&gt; <span class="cppkeyword">struct</span> hash;
  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">struct</span> hash&lt;wide_integer&lt;MachineWords, S&gt;&gt;;


  <span class="cppkeyword">template</span> &lt;size_t MachineWords, signedness S&gt;
  to_chars_result to_chars(char* first,
                          <span class="cppkeyword"> char</span>* last,
                           <span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; value,
                           int base = 10);

  <span class="cppkeyword">template</span> &lt;size_t MachineWords, signedness S&gt;
  from_chars_result from_chars(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>* first,
                               <span class="cppkeyword">const</span><span class="cppkeyword"> char</span>* last,
                               wide_integer&lt;MachineWords, S&gt;&amp; value,
                               int base = 10);

  <span class="cppkeyword">template</span> &lt;size_t MachineWords&gt;
  using wide_int = wide_integer&lt;MachineWords, signedness::Signed&gt;;

  <span class="cppkeyword">template</span> &lt;size_t MachineWords&gt;
  using wide_uint = wide_integer&lt;MachineWords, signedness::Unsigned&gt;
</pre>
<p class="notes"><b><i>[Note to SG6:</i></b> Following part requires updated <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0102r0.html">P0102R0</a> 
proposal with <code>exact_2int</code>, <code>fast_2int</code>, <code>least_2int</code>,
<code>exact_2uint</code>, <code>fast_2uint</code>, <code>least_2uint</code> specializations for <code>wide_integer</code>.
 <i><b>- end note]</b></i></p>

<pre>  <span class="cppcomment">// optional aliases
</span>  using int128_t  = exact_2int&lt;128&gt;;      <span class="cppcomment">// <i>wide_int&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>  using uint128_t = exact_2uint&lt;128&gt;;     <span class="cppcomment">// <i>wide_uint&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>
  using int256_t  = exact_2int&lt;256&gt;;      <span class="cppcomment">// <i>wide_int&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>  using uint256_t = exact_2uint&lt;256&gt;;     <span class="cppcomment">// <i>wide_uint&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>
  using int512_t  = exact_2int&lt;512&gt;;      <span class="cppcomment">// <i>wide_int&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>  using uint512_t = exact_2uint&lt;512&gt;;     <span class="cppcomment">// <i>wide_uint&lt;platform-specific&gt;</i> or <i>platform-specific build in type</i>
</span>

  <span class="cppcomment">// non optional aliases
</span>  using int_fast128_t  = fast_2int&lt;128&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_fast128_t = fast_2uint&lt;128&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>
  using int_fast256_t  = fast_2int&lt;256&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_fast256_t = fast_2uint&lt;256&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>
  using int_fast512_t  = fast_2int&lt;512&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_fast512_t = fast_2uint&lt;512&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>

  using int_least128_t  = least_2int&lt;128&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_least128_t = least_2uint&lt;128&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>
  using int_least256_t  = least_2int&lt;256&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_least256_t = least_2uint&lt;256&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>
  using int_least512_t  = least_2int&lt;512&gt;;   <span class="cppcomment">// wide_int&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>  using uint_least512_t = least_2uint&lt;512&gt;;  <span class="cppcomment">// wide_uint&lt;<i>platform-specific</i>&gt;<span class="changed-added"> or <i>platform-specific build in type</i></span>
</span>

  <span class="cppcomment">// optional literals
</span>  <span class="cppkeyword">inline</span> <span class="cppkeyword">namespace</span> literals {
  <span class="cppkeyword">inline</span> <span class="cppkeyword">namespace</span> wide_int_literals {

  <span class="cppkeyword">constexpr</span> int128_t <span class="cppkeyword">operator</span> "" _int128(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);
  <span class="cppkeyword">constexpr</span> int256_t <span class="cppkeyword">operator</span> "" _int256(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);
  <span class="cppkeyword">constexpr</span> int512_t <span class="cppkeyword">operator</span> "" _int512(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);
  <span class="cppkeyword">constexpr</span> uint128_t <span class="cppkeyword">operator</span> "" _uint128(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);
  <span class="cppkeyword">constexpr</span> uint256_t <span class="cppkeyword">operator</span> "" _uint256(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);
  <span class="cppkeyword">constexpr</span> uint512_t <span class="cppkeyword">operator</span> "" _uint512(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>*);

  } <span class="cppcomment">// <span class="cppkeyword">namespace</span> wide_int_literals
</span>  } <span class="cppcomment">// <span class="cppkeyword">namespace</span> literals
</span>}
</pre>
<p>The header &lt;wide_integer&gt; defines class template <code>wide_integer</code> and a set of operators for representing and manipulating integers of specified width.</p><pre>[Example:
    <span class="cppkeyword">constexpr</span> int128_t c = std::numeric_limits&lt;int128_t&gt;::min();
    <span class="cppkeyword">static_assert</span>(c == 0x80000000000000000000000000000000_uint128);

    int256_t a = 13;
    a += 0xFF;
    a *= 2.0;
    a -= 12_int128;
    assert(a &gt; 0);
]</pre>


<h3>26.??.2 Template class wide_integer overview<span class="right">[numeric.wide_integer.overview]</span></h3>
<pre><span class="cppkeyword">namespace</span> std {
  <span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt;
  <span class="cppkeyword">class </span>wide_integer {
  <span class="cppkeyword">public</span>:
    <span class="cppcomment">// 26.??.2.?? <span class="cppkeyword">const</span>ruct:
</span>    <span class="cppkeyword">constexpr</span> wide_integer() <span class="cppkeyword">noexcept</span> = default;
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer(<span class="cppkeyword">const</span> Arithmetic&amp; other) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; other) <span class="cppkeyword">noexcept</span>;

    <span class="cppcomment">// 26.??.2.?? assignment:
</span>    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const</span> Arithmetic&amp; other) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; other) <span class="cppkeyword">noexcept</span>;

    <span class="cppcomment">// 26.??.2.?? compound assignment:
</span>    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>*=(<span class="cppkeyword">const</span> Arithmetic&amp;);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>*=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>/=(<span class="cppkeyword">const</span> Arithmetic&amp;);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>/=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>+=(<span class="cppkeyword">const</span> Arithmetic&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>+=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>-=(<span class="cppkeyword">const</span> Arithmetic&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>-=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>%=(<span class="cppkeyword">const</span> Integral&amp;);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>%=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&amp;=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&amp;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>|=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>|=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>^=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>^=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;=(<span class="cppkeyword">const</span> Integral&amp;);
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;

    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>++() <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>++(int) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>--() <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
    <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>--(int) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);

    <span class="cppcomment">// 26.??.2.?? observers:
</span>    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span> Arithmetic() <span class="cppkeyword">const</span> <span class="cppkeyword">noexcept</span>;
    <span class="cppkeyword">constexpr</span> <span class="cppkeyword">explicit</span> <span class="cppkeyword">operator</span> <span class="cppkeyword">bool</span>() <span class="cppkeyword">const</span> <span class="cppkeyword">noexcept</span>;

  <span class="cppkeyword">private</span>:
    uint32_t data[MachineWords / <span class="cppkeyword">sizeof</span>(uint32_t) + 1]; <span class="cppcomment">// exposition only
</span>  };
}</pre>
<p>The class template <code>wide_integer&lt;size_t MachineWords, signedness S&gt;</code> is a POD class that behaves as an integer type
of a compile time specified width. Template parameter <code>MachineWords</code> specifies exact <i>machine words</i> count to store the integer value.
<code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, signedness::Unsigned&gt;)</code> and <code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, signedness::Signed&gt;)</code> are required to
be equal to <code>MachineWords * <span class="cppkeyword">sizeof</span>(<i>machine-word</i>)</code>. Template parameter <code>S</code> specifies signedness of the stored integer value.</p>

<p class="notes"><b><i>[Note to SG6:</i></b> Definition for <i>machine words</i> must be provided somewhere and referenced from the above paragraph. <i><b>- end note]</b></i></p>


<h4>26.??.2.?? wide_integer constructors <span class="right">[numeric.wide_integer.cons]</span></h4>
<pre><span class="cppkeyword">constexpr</span> wide_integer() <span class="cppkeyword">noexcept</span> = default;</pre>
<div class="desc"><i>Effects:</i> A Constructs an object with undefined value.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer(<span class="cppkeyword">const</span> Arithmetic&amp; other) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Effects:</i> Constructs an object from <code>other</code> using the integral conversion rules [conv.integral].</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; other) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Effects:</i> Constructs an object from <code>other</code> using the integral conversion rules [conv.integral].</div>

<h4>26.??.2.?? wide_integer assignments <span class="right">[numeric.wide_integer.assign]</span></h4>
<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt;
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const</span> Arithmetic&amp; other) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Effects:</i> Constructs an object from <code>other</code> using the integral conversion rules [conv.integral].</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt;
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; other) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Effects:</i> Constructs an object from <code>other</code> using the integral conversion rules [conv.integral].</div>

<h4>26.??.2.?? wide_integer compound assignments <span class="right">[numeric.wide_integer.cassign]</span></h4>
<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>*=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>/=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>+=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>-=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>%=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&amp;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>|=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>^=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;);
<span class="cppkeyword">template</span>&lt;size_t MachineWords2, signedness S2&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>++() <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>++(int) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>--() <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>--(int) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Effects:</i> Behavior of the above operators is similar to operators for built-in integral types.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>*=(<span class="cppkeyword">const</span> Arithmetic&amp;);
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>/=(<span class="cppkeyword">const</span> Arithmetic&amp;);
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>+=(<span class="cppkeyword">const</span> Arithmetic&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>-=(<span class="cppkeyword">const</span> Arithmetic&amp;) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Effects:</i> As if an object <code>wi</code> of type <code>wide_integer&lt;MachineWords, S&gt;</code> was created from input value and the corresponding operator was called for <code>*this</code> and the <code>wi</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>%=(<span class="cppkeyword">const</span> Integral&amp;);
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&amp;=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>|=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>^=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;=(<span class="cppkeyword">const</span> Integral&amp;);
<span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Integral&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;=(<span class="cppkeyword">const</span> Integral&amp;) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Effects:</i> As if an object <code>wi</code> of type <code>wide_integer&lt;MachineWords, S&gt;</code> was created from input value and the corresponding operator was called for <code>*this</code> and the <code>wi</code>.</div>


<h4>26.??.2.?? wide_integer observers <span class="right">[numeric.wide_integer.observers]</span></h4>
<pre><span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> Arithmetic&gt; <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span> Arithmetic() <span class="cppkeyword">const</span> <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> If <code>Arithmetic</code> type is an integral type then it is constructed from <code>*this</code> using the integral conversion rules [conv.integral]. Otherwise <code>Arithmetic</code> is constructed from <code>*this</code> using the floating-integral conversion rules [conv.fpint].</div>

<pre><span class="cppkeyword">constexpr</span> <span class="cppkeyword">explicit</span> <span class="cppkeyword">operator</span> <span class="cppkeyword">bool</span>() <span class="cppkeyword">const</span> <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if <code>*this</code> is not equal to 0.</div>


<h3>26.??.?? Specializations of common_type <span class="right">[numeric.wide_integer.traits.specializations]</span></h3>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
<span class="cppkeyword">struct</span> common_type&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt; {
  using type = wide_integer&lt;max(MachineWords, MachineWords2), <i>see below</i>&gt;;
};</pre>

<p>The signed template parameter indicated by this specialization is following:</p>
<ul>
  <li><code>(S == signedness::Signed &amp;&amp; S2 == signedness::Signed ? signedness::Signed : signedness::Unsigned)</code> if <code>MachineWords == MachineWords2</code></li>
  <li><code>S</code> if <code>MachineWords &gt; MachineWords2</code></li>
  <li><code>S2</code> otherwise</li>
</ul>
<p><i>[Note: </i> <code>common_type</code> follows the <i>usual arithmetic conversions</i> design. <i>- end note]</i></p>

<p class="notes"><b><i>[Note to SG6:</i></b> <code>common_type</code> attempts to follow the <i>usual arithmetic conversions</i>
 design here for interoperability between different numeric types. 
Following two specializations must be moved to a more generic place and 
enriched with usual arithmetic conversion rules for <b>all the other</b> numeric classes that specialize <code>std::numeric_limits</code><i><b>- end note]</b></i></p>
<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, <span class="cppkeyword">typename</span> Arithmetic&gt;
<span class="cppkeyword">struct</span> common_type&lt;wide_integer&lt;MachineWords, S&gt;, Arithmetic&gt; {
  using type = <i>see below</i>;
};</pre>

<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> Arithmetic, size_t MachineWords, signedness S&gt;
<span class="cppkeyword">struct</span> common_type&lt;Arithmetic, wide_integer&lt;MachineWords, S&gt;&gt;
  : common_type&lt;wide_integer&lt;MachineWords, S&gt;, Arithmetic&gt;;
</pre>

<p>The member typedef <code>type</code> is following:</p>
<ul>
  <li><code>Arithmetic</code> if <code>numeric_limits&lt;Arithmetic&gt;::is_integer</code> is <code>false</code></li>
  <li><code>wide_integer&lt;MachineWords, S&gt;</code> if <code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, S&gt;) &gt; <span class="cppkeyword">sizeof</span>(Arithmetic)</code></li>
  <li><code>Arithmetic</code> if <code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, S&gt;) &lt; <span class="cppkeyword">sizeof</span>(Arithmetic)</code></li>
  <li><code>Arithmetic</code> if <code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, S&gt;) == <span class="cppkeyword">sizeof</span>(Arithmetic) &amp;&amp; S == signedness::Signed</code></li>
  <li><code>Arithmetic</code> if <code><span class="cppkeyword">sizeof</span>(wide_integer&lt;MachineWords, S&gt;) == <span class="cppkeyword">sizeof</span>(Arithmetic)
 &amp;&amp; numeric_limits&lt;wide_integer&lt;MachineWords, 
S&gt;&gt;::is_signed == numeric_limits&lt;Arithmetic&gt;::is_signed</code></li>
  <li><code>wide_integer&lt;MachineWords, S&gt;</code> otherwise</li>
</ul>

<h3>26.??.?? Unary operators <span class="right">[numeric.wide_integer.unary_ops]</span></h3>
<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>~(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> value with inverted significant bits of <code>val</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>-(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Returns:</i> <code>val *= -1</code> if <code>S</code> is true, otherwise the result is unspecified.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">constexpr</span> wide_integer&lt;MachineWords, S&gt; <span class="cppkeyword">operator</span>+(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Returns:</i> <code>val</code>.</div>

<h3>26.??.?? Binary operators <span class="right">[numeric.wide_integer.binary_ops]</span></h3>
<p>In the function descriptions that follow, <code>CT</code> represents <code>common_type_t&lt;A, B&gt;</code>, where <code>A</code> and <code>B</code> are the types of the two arguments to the function.</p>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>*(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) *= rhs</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>/(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) /= rhs</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>+(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) += rhs</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>-(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>(S == signedness::Unsigned);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) -= rhs</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>%(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) %= rhs</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&amp;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &amp;= rhs</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>|(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) |= rhs</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, wide_integer&lt;MachineWords2, S2&gt;&gt;
  <span class="cppkeyword">constexpr</span>  <span class="cppkeyword">operator</span>^(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) ^= rhs</code>.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, size_t&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&lt;&lt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, size_t rhs);</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &lt;&lt;= rhs</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt;
  common_type_t&lt;wide_integer&lt;MachineWords, S&gt;, size_t&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">operator</span>&gt;&gt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, size_t rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>CT(lhs) &gt;&gt;= rhs</code>.</div>




<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if value of <code>CT(lhs)</code> is less than the value of <code>CT(rhs)</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if value of <code>CT(lhs)</code> is greater than the value of <code>CT(rhs)</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&lt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if value of <code>CT(lhs)</code> is equal or less than the value of <code>CT(rhs)</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>&gt;=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if value of <code>CT(lhs)</code> is equal or greater than the value of <code>CT(rhs)</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>==(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>true</code> if significant bits of <code>CT(lhs)</code> and <code>CT(rhs)</code> are the same.</div>

<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S, size_t MachineWords2, signedness S2&gt;
  <span class="cppkeyword">constexpr</span> <span class="cppkeyword">bool</span> <span class="cppkeyword">operator</span>!=(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; lhs, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords2, S2&gt;&amp; rhs) <span class="cppkeyword">noexcept</span>;</pre>
<div class="desc"><i>Returns:</i> <code>!(CT(lhs) == CT(rhs))</code>.</div>



<h3>26.??.?? Numeric conversions <span class="right">[numeric.wide_integer.conversions]</span></h3>
<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; std::string to_string(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);
<span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; std::wstring to_wstring(<span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);</pre>
<div class="desc"><i>Returns:</i> Each function returns an object 
holding the character representation of the value of its argument. All 
the significant bits of the argument are outputed as a signed decimal in
 the style <code>[-]dddd</code>.</div>

<div>
<pre><span class="cppkeyword">template</span> &lt;size_t MachineWords, signedness S&gt;
to_chars_result to_chars(char* first,
                      <span class="cppkeyword"> char</span>* last,
                       <span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; value,
                       int base = 10);
</pre>
<p>Behavior of <code>wide_integer</code> overload is subject to the usual rules of primitive numeric output conversion functions [utility.to.chars].</p>

<pre><span class="cppkeyword">template</span> &lt;size_t MachineWords, signedness S&gt;
from_chars_result from_chars(<span class="cppkeyword">const</span><span class="cppkeyword"> char</span>* first,
                           <span class="cppkeyword">const</span><span class="cppkeyword"> char</span>* last,
                           wide_integer&lt;MachineWords, S&gt;&amp; value,
                           int base = 10);
</pre>
<p>Behavior of <code>wide_integer</code> overload is subject to the usual rules of primitive numeric input conversion functions [utility.from.chars].</p>
</div>

<h3>26.??.?? iostream specializations <span class="right">[numeric.wide_integer.io]</span></h3>
<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>Char, <span class="cppkeyword">class </span>Traits, size_t MachineWords, signedness S&gt;
basic_ostream&lt;Char, Traits&gt;&amp; <span class="cppkeyword">operator</span>&lt;&lt;(basic_ostream&lt;Char, Traits&gt;&amp; os, <span class="cppkeyword">const</span> wide_integer&lt;MachineWords, S&gt;&amp; val);</pre>
<div class="desc"><i>Effects:</i> As if by: <code>os &lt;&lt; to_string(val)</code>.</div>
<div class="desc"><i>Returns:</i> <code>os</code>.</div>


<pre><span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>Char, <span class="cppkeyword">class </span>Traits, size_t MachineWords, signedness S&gt;
basic_istream&lt;Char, Traits&gt;&amp; <span class="cppkeyword">operator</span>&gt;&gt;(basic_istream&lt;Char, Traits&gt;&amp; is, wide_integer&lt;MachineWords, S&gt;&amp; val);</pre>
<div class="desc"><i>Effects:</i> Extracts a <code>wide_integer</code> that is represented as a decimal number in the <code>is</code>. If bad input is encountered, calls <code>is.setstate(ios_base::failbit)</code> (which may throw <code>ios::failure</code> ([iostate.flags])).</div>
<div class="desc"><i>Returns:</i> <code>is</code>.</div>


<h3>26.??.?? Hash support <span class="right">[numeric.wide_integer.hash]</span></h3>
<pre><span class="cppkeyword">template</span>&lt;size_t MachineWords, signedness S&gt; <span class="cppkeyword">struct</span> hash&lt;wide_integer&lt;MachineWords, S&gt;&gt;;</pre>
<p>The specialization is enabled (20.14.14). If there is a built-in integral type <code>Integral</code> that has the same signedness and width as <code>wide_integer&lt;MachineWords, S&gt;</code>, and <code>wi</code> is an object of type <code>wide_integer&lt;MachineWords, S&gt;</code>, then <code>hash&lt;wide_integer&lt;MachineWords, S&gt;&gt;()(wi) == hash&lt;Integral&gt;()(Integral(wi))</code>.</p>


        <h2>V. Feature-testing macro</h2>
        <p>For the purposes of SG10we recommend the feature-testing macro name <code>__cpp_lib_wide_integer</code>.</p>


        <script type="text/javascript">
            function colorize_texts(texts) {
                for (var i = 0; i < texts.length; ++i) {
                    var text = texts[i].innerHTML;
                    text = text.replace(/namespace|sizeof|long|enum|void|constexpr|extern|noexcept|bool|template|class |struct|auto|const|typename|explicit|public|private|operator|#include|inline| char|typedef|static_assert|static_cast|static/g,"<span class='cppkeyword'>$&<\/span>");
                    text = text.replace(/\/\/[\s\S]+?\n/g,"<span class='cppcomment'>$&<\/span>");
                    //text = text.replace(/\"[\s\S]+?\"/g,"<span class='cpptext'>$&<\/span>");
                    texts[i].innerHTML = text;
                }
            }

            colorize_texts(document.getElementsByTagName("pre"));
            colorize_texts(document.getElementsByTagName("code"));

            function show_hide_deleted() {
                var to_change = document.getElementsByClassName('changed-deleted');
                for (var i = 0; i < to_change.length; ++i) {
                    to_change[i].style.display = (document.getElementById("show_deletions").checked ? 'block' : 'none');
                }
            }
            show_hide_deleted()
        </script>

</body></html>